
Lab01.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00000c20  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  80002e00  80002e00  00003200  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000000d4  80003000  80003000  00003400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .lalign       00000004  800030d4  800030d4  000034d4  2**0
                  ALLOC
  6 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  7 .data         00000010  00000008  800030d8  00003808  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .bss          00000110  00000018  00000018  00000000  2**2
                  ALLOC
  9 .heap         0000eed8  00000128  00000128  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  00003818  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 000005c0  00000000  00000000  00003848  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 00000e76  00000000  00000000  00003e08  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   0000ade4  00000000  00000000  00004c7e  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 000011cb  00000000  00000000  0000fa62  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   00003c29  00000000  00000000  00010c2d  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00000c7c  00000000  00000000  00014858  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00002151  00000000  00000000  000154d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    00001aa4  00000000  00000000  00017625  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_macinfo 00678cce  00000000  00000000  000190c9  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .stack        00001000  0000f000  0000f000  00000000  2**0
                  ALLOC
 21 .debug_ranges 00000558  00000000  00000000  00691d98  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf d4 14 	sub	pc,pc,-11244

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf f4 18 	sub	pc,pc,-3048

Disassembly of section .text:

80002008 <tc_init_waveform>:
80002008:	76 09       	ld.w	r9,r11[0x0]
8000200a:	58 29       	cp.w	r9,2


int tc_init_waveform(volatile avr32_tc_t *tc, const tc_waveform_opt_t *opt)
{
  // Check for valid input.
  if (opt->channel >= TC_NUMBER_OF_CHANNELS)
8000200c:	e0 88 00 03 	brls	80002012 <tc_init_waveform+0xa>
80002010:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // GENERATE SIGNALS: Waveform operating mode.
  tc->channel[opt->channel].cmr = opt->bswtrg << AVR32_TC_BSWTRG_OFFSET |
80002012:	76 18       	ld.w	r8,r11[0x4]
80002014:	f5 d8 c0 03 	bfextu	r10,r8,0x0,0x3
80002018:	af ba       	sbr	r10,0xf
8000201a:	10 9b       	mov	r11,r8
8000201c:	e6 1b c0 00 	andh	r11,0xc000,COH
80002020:	16 4a       	or	r10,r11
80002022:	10 9b       	mov	r11,r8
80002024:	e6 1b 30 00 	andh	r11,0x3000,COH
80002028:	16 4a       	or	r10,r11
8000202a:	10 9b       	mov	r11,r8
8000202c:	e6 1b 0c 00 	andh	r11,0xc00,COH
80002030:	16 4a       	or	r10,r11
80002032:	10 9b       	mov	r11,r8
80002034:	e6 1b 03 00 	andh	r11,0x300,COH
80002038:	16 4a       	or	r10,r11
8000203a:	10 9b       	mov	r11,r8
8000203c:	e6 1b 00 c0 	andh	r11,0xc0,COH
80002040:	16 4a       	or	r10,r11
80002042:	10 9b       	mov	r11,r8
80002044:	e6 1b 00 30 	andh	r11,0x30,COH
80002048:	16 4a       	or	r10,r11
8000204a:	10 9b       	mov	r11,r8
8000204c:	e6 1b 00 0c 	andh	r11,0xc,COH
80002050:	16 4a       	or	r10,r11
80002052:	10 9b       	mov	r11,r8
80002054:	e6 1b 00 03 	andh	r11,0x3,COH
80002058:	16 4a       	or	r10,r11
8000205a:	10 9b       	mov	r11,r8
8000205c:	e2 1b 60 00 	andl	r11,0x6000,COH
80002060:	16 4a       	or	r10,r11
80002062:	f7 d8 c1 81 	bfextu	r11,r8,0xc,0x1
80002066:	f5 eb 10 ca 	or	r10,r10,r11<<0xc
8000206a:	10 9b       	mov	r11,r8
8000206c:	e2 1b 0c 00 	andl	r11,0xc00,COH
80002070:	16 4a       	or	r10,r11
80002072:	10 9b       	mov	r11,r8
80002074:	e2 1b 03 00 	andl	r11,0x300,COH
80002078:	16 4a       	or	r10,r11
8000207a:	f7 d8 c0 e1 	bfextu	r11,r8,0x7,0x1
8000207e:	f5 eb 10 7a 	or	r10,r10,r11<<0x7
80002082:	f7 d8 c0 c1 	bfextu	r11,r8,0x6,0x1
80002086:	f5 eb 10 6a 	or	r10,r10,r11<<0x6
8000208a:	10 9b       	mov	r11,r8
8000208c:	e2 1b 00 30 	andl	r11,0x30,COH
80002090:	16 4a       	or	r10,r11
80002092:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
80002096:	f5 e8 10 38 	or	r8,r10,r8<<0x3
8000209a:	a5 69       	lsl	r9,0x4
8000209c:	2f f9       	sub	r9,-1
8000209e:	f8 09 09 28 	st.w	r12[r9<<0x2],r8
800020a2:	5e fd       	retal	0

800020a4 <tc_start>:


int tc_start(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800020a4:	58 2b       	cp.w	r11,2
800020a6:	e0 88 00 03 	brls	800020ac <tc_start+0x8>
800020aa:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Enable, reset and start the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_SWTRG_MASK | AVR32_TC_CLKEN_MASK;
800020ac:	a7 6b       	lsl	r11,0x6
800020ae:	16 0c       	add	r12,r11
800020b0:	30 58       	mov	r8,5
800020b2:	99 08       	st.w	r12[0x0],r8
800020b4:	5e fd       	retal	0

800020b6 <tc_stop>:


int tc_stop(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800020b6:	58 2b       	cp.w	r11,2
800020b8:	e0 88 00 03 	brls	800020be <tc_stop+0x8>
800020bc:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // Disable the selected timer/counter channel.
  tc->channel[channel].ccr = AVR32_TC_CLKDIS_MASK;
800020be:	a7 6b       	lsl	r11,0x6
800020c0:	16 0c       	add	r12,r11
800020c2:	30 28       	mov	r8,2
800020c4:	99 08       	st.w	r12[0x0],r8
800020c6:	5e fd       	retal	0

800020c8 <tc_read_sr>:


int tc_read_sr(volatile avr32_tc_t *tc, unsigned int channel)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800020c8:	58 2b       	cp.w	r11,2
800020ca:	e0 88 00 03 	brls	800020d0 <tc_read_sr+0x8>
800020ce:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  return tc->channel[channel].sr;
800020d0:	a7 6b       	lsl	r11,0x6
800020d2:	2e 0b       	sub	r11,-32
800020d4:	16 0c       	add	r12,r11
800020d6:	78 0c       	ld.w	r12,r12[0x0]
}
800020d8:	5e fc       	retal	r12

800020da <tc_write_rc>:


int tc_write_rc(volatile avr32_tc_t *tc, unsigned int channel, unsigned short value)
{
  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
800020da:	58 2b       	cp.w	r11,2
800020dc:	e0 88 00 03 	brls	800020e2 <tc_write_rc+0x8>
800020e0:	5e fe       	retal	-1
    return TC_INVALID_ARGUMENT;

  // This function is only available in WAVEFORM mode.
  if (Tst_bits(tc->channel[channel].cmr, AVR32_TC_WAVE_MASK))
800020e2:	f6 08 15 04 	lsl	r8,r11,0x4
800020e6:	2f f8       	sub	r8,-1
800020e8:	f8 08 03 28 	ld.w	r8,r12[r8<<0x2]
800020ec:	e2 18 80 00 	andl	r8,0x8000,COH
800020f0:	c0 c0       	breq	80002108 <tc_write_rc+0x2e>
    Wr_bitfield(tc->channel[channel].rc, AVR32_TC_RC_MASK, value);
800020f2:	a7 6b       	lsl	r11,0x6
800020f4:	16 0c       	add	r12,r11
800020f6:	2e 4c       	sub	r12,-28
800020f8:	78 08       	ld.w	r8,r12[0x0]
800020fa:	f3 da c0 10 	bfextu	r9,r10,0x0,0x10
800020fe:	e0 18 00 00 	andl	r8,0x0
80002102:	f3 e8 10 08 	or	r8,r9,r8
80002106:	99 08       	st.w	r12[0x0],r8

  return value;
80002108:	f9 da c0 10 	bfextu	r12,r10,0x0,0x10
}
8000210c:	5e fc       	retal	r12

8000210e <tc_configure_interrupts>:
  return tc->channel[channel].imr;
}


int tc_configure_interrupts(volatile avr32_tc_t *tc, unsigned int channel, const tc_interrupt_t *bitfield)
{
8000210e:	eb cd 40 fc 	pushm	r2-r7,lr
  bool global_interrupt_enabled = Is_global_interrupt_enabled();
80002112:	e1 b9 00 00 	mfsr	r9,0x0

  // Check for valid input.
  if (channel >= TC_NUMBER_OF_CHANNELS)
80002116:	58 2b       	cp.w	r11,2
80002118:	e0 88 00 04 	brls	80002120 <tc_configure_interrupts+0x12>
8000211c:	e3 cf c0 fc 	ldm	sp++,r2-r7,pc,r12=-1
	return flags;
}

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
	return !(flags & AVR32_SR_GM_MASK);
80002120:	ee 19 00 01 	eorh	r9,0x1
80002124:	f3 d9 c2 01 	bfextu	r9,r9,0x10,0x1
    return TC_INVALID_ARGUMENT;

  // Enable the appropriate interrupts.
  tc->channel[channel].ier = bitfield->etrgs << AVR32_TC_ETRGS_OFFSET |
80002128:	74 08       	ld.w	r8,r10[0x0]
8000212a:	ef d8 c0 e1 	bfextu	r7,r8,0x7,0x1
8000212e:	fd d8 c0 c1 	bfextu	lr,r8,0x6,0x1
80002132:	a7 6e       	lsl	lr,0x6
80002134:	fd e7 10 7e 	or	lr,lr,r7<<0x7
80002138:	ef d8 c0 01 	bfextu	r7,r8,0x0,0x1
8000213c:	0e 4e       	or	lr,r7
8000213e:	ef d8 c0 a1 	bfextu	r7,r8,0x5,0x1
80002142:	fd e7 10 5e 	or	lr,lr,r7<<0x5
80002146:	ef d8 c0 81 	bfextu	r7,r8,0x4,0x1
8000214a:	fd e7 10 4e 	or	lr,lr,r7<<0x4
8000214e:	ef d8 c0 61 	bfextu	r7,r8,0x3,0x1
80002152:	fd e7 10 3e 	or	lr,lr,r7<<0x3
80002156:	ef d8 c0 41 	bfextu	r7,r8,0x2,0x1
8000215a:	fd e7 10 2e 	or	lr,lr,r7<<0x2
8000215e:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
80002162:	fd e8 10 18 	or	r8,lr,r8<<0x1
80002166:	f6 0e 15 06 	lsl	lr,r11,0x6
8000216a:	f8 0e 00 0e 	add	lr,r12,lr
8000216e:	2d ce       	sub	lr,-36
80002170:	9d 08       	st.w	lr[0x0],r8
                             bitfield->cpas << AVR32_TC_CPAS_OFFSET |
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
80002172:	58 09       	cp.w	r9,0
80002174:	c0 20       	breq	80002178 <tc_configure_interrupts+0x6a>
80002176:	d3 03       	ssrf	0x10
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
80002178:	74 08       	ld.w	r8,r10[0x0]
8000217a:	f1 d8 c0 e1 	bfextu	r8,r8,0x7,0x1
8000217e:	e0 65 00 80 	mov	r5,128
80002182:	f9 b5 01 00 	movne	r5,0
                             (~bitfield->ldrbs & 1) << AVR32_TC_LDRBS_OFFSET |
80002186:	74 08       	ld.w	r8,r10[0x0]
80002188:	f1 d8 c0 c1 	bfextu	r8,r8,0x6,0x1
8000218c:	f9 b4 00 40 	moveq	r4,64
80002190:	f9 b4 01 00 	movne	r4,0
                             (~bitfield->ldras & 1) << AVR32_TC_LDRAS_OFFSET |
80002194:	74 08       	ld.w	r8,r10[0x0]
80002196:	f1 d8 c0 a1 	bfextu	r8,r8,0x5,0x1
8000219a:	f9 b3 00 20 	moveq	r3,32
8000219e:	f9 b3 01 00 	movne	r3,0
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
800021a2:	74 08       	ld.w	r8,r10[0x0]
800021a4:	f1 d8 c0 81 	bfextu	r8,r8,0x4,0x1
800021a8:	f9 b2 00 10 	moveq	r2,16
800021ac:	f9 b2 01 00 	movne	r2,0
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
800021b0:	74 08       	ld.w	r8,r10[0x0]
800021b2:	f1 d8 c0 61 	bfextu	r8,r8,0x3,0x1
800021b6:	f9 b6 00 08 	moveq	r6,8
800021ba:	f9 b6 01 00 	movne	r6,0
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
800021be:	74 08       	ld.w	r8,r10[0x0]
800021c0:	f1 d8 c0 41 	bfextu	r8,r8,0x2,0x1
800021c4:	f9 b7 00 04 	moveq	r7,4
800021c8:	f9 b7 01 00 	movne	r7,0
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
800021cc:	74 08       	ld.w	r8,r10[0x0]
800021ce:	f1 d8 c0 21 	bfextu	r8,r8,0x1,0x1
800021d2:	f9 be 00 02 	moveq	lr,2
800021d6:	f9 be 01 00 	movne	lr,0
                             bitfield->lovrs << AVR32_TC_LOVRS_OFFSET |
                             bitfield->covfs << AVR32_TC_COVFS_OFFSET;

  // Disable the appropriate interrupts.
  if (global_interrupt_enabled) Disable_global_interrupt();
  tc->channel[channel].idr = (~bitfield->etrgs & 1) << AVR32_TC_ETRGS_OFFSET |
800021da:	74 08       	ld.w	r8,r10[0x0]
800021dc:	ec 18 00 01 	eorl	r8,0x1
800021e0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800021e4:	eb e8 10 08 	or	r8,r5,r8
800021e8:	08 48       	or	r8,r4
800021ea:	06 48       	or	r8,r3
800021ec:	04 48       	or	r8,r2
800021ee:	0c 48       	or	r8,r6
800021f0:	0e 48       	or	r8,r7
800021f2:	1c 48       	or	r8,lr
800021f4:	f6 0a 15 06 	lsl	r10,r11,0x6
800021f8:	f8 0a 00 0a 	add	r10,r12,r10
800021fc:	2d 8a       	sub	r10,-40
800021fe:	95 08       	st.w	r10[0x0],r8
                             (~bitfield->cpcs & 1) << AVR32_TC_CPCS_OFFSET |
                             (~bitfield->cpbs & 1) << AVR32_TC_CPBS_OFFSET |
                             (~bitfield->cpas & 1) << AVR32_TC_CPAS_OFFSET |
                             (~bitfield->lovrs & 1) << AVR32_TC_LOVRS_OFFSET |
                             (~bitfield->covfs & 1) << AVR32_TC_COVFS_OFFSET;
  tc->channel[channel].sr;
80002200:	a7 6b       	lsl	r11,0x6
80002202:	2e 0b       	sub	r11,-32
80002204:	16 0c       	add	r12,r11
80002206:	78 08       	ld.w	r8,r12[0x0]
  if (global_interrupt_enabled) Enable_global_interrupt();
80002208:	58 09       	cp.w	r9,0
8000220a:	c0 31       	brne	80002210 <tc_configure_interrupts+0x102>
8000220c:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80002210:	d5 03       	csrf	0x10
80002212:	e3 cf 80 fc 	ldm	sp++,r2-r7,pc,r12=0
80002216:	d7 03       	nop

80002218 <usart_irq_handler>:
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80002218:	fe 78 14 00 	mov	r8,-60416
8000221c:	70 58       	ld.w	r8,r8[0x14]
}

__attribute__((__interrupt__))
void usart_irq_handler(void)
{
	if (usart_test_hit(&AVR32_USART0))
8000221e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002222:	c0 70       	breq	80002230 <usart_irq_handler+0x18>
	{
		//get command
		uart_received_command = (AVR32_USART0.rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80002224:	fe 78 14 00 	mov	r8,-60416
80002228:	70 69       	ld.w	r9,r8[0x18]
8000222a:	48 98       	lddpc	r8,8000224c <usart_irq_handler+0x34>
8000222c:	b0 89       	st.b	r8[0x0],r9
8000222e:	d6 03       	rete
 * \return \c 1 if the USART Transmit Shift Register and the USART Transmit
 *         Holding Register are free, otherwise \c 0.
 */
__always_inline static int usart_tx_empty(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXEMPTY_MASK) != 0;
80002230:	fe 78 14 00 	mov	r8,-60416
80002234:	70 58       	ld.w	r8,r8[0x14]
	}
	else if (usart_tx_empty(&AVR32_USART0))
80002236:	e2 18 02 00 	andl	r8,0x200,COH
8000223a:	c0 80       	breq	8000224a <usart_irq_handler+0x32>
	{
		uart_transmission_completed = 1;
8000223c:	30 19       	mov	r9,1
8000223e:	48 58       	lddpc	r8,80002250 <usart_irq_handler+0x38>
80002240:	b0 89       	st.b	r8[0x0],r9
		AVR32_USART0.idr = AVR32_USART_IER_TXRDY_MASK;
80002242:	30 29       	mov	r9,2
80002244:	fe 78 14 00 	mov	r8,-60416
80002248:	91 39       	st.w	r8[0xc],r9
8000224a:	d6 03       	rete
8000224c:	00 00       	add	r0,r0
8000224e:	00 34       	cp.w	r4,r0
80002250:	00 00       	add	r0,r0
80002252:	00 35       	cp.w	r5,r0

80002254 <led_gpio_assign_pin>:
						FUNCTIONS 
*///////////////////////////////////////////////////////////

void led_gpio_assign_pin(uint32_t pin, uint8_t value)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80002254:	f8 08 16 05 	lsr	r8,r12,0x5
80002258:	a9 68       	lsl	r8,0x8
8000225a:	e0 28 f0 00 	sub	r8,61440
	
	if (value)
8000225e:	58 0b       	cp.w	r11,0
80002260:	c0 70       	breq	8000226e <led_gpio_assign_pin+0x1a>
	{
		gpio_port->ovrs = 1 << (pin & 0x1F);
80002262:	30 19       	mov	r9,1
80002264:	f2 0c 09 49 	lsl	r9,r9,r12
80002268:	f1 49 00 54 	st.w	r8[84],r9
8000226c:	c0 68       	rjmp	80002278 <led_gpio_assign_pin+0x24>
	}
	else
	{
		gpio_port->ovrc = 1 << (pin & 0x1F);
8000226e:	30 19       	mov	r9,1
80002270:	f2 0c 09 49 	lsl	r9,r9,r12
80002274:	f1 49 00 58 	st.w	r8[88],r9
	}
	
	gpio_port->oders = 1 << (pin & 0x1F);
80002278:	30 19       	mov	r9,1
8000227a:	f2 0c 09 4c 	lsl	r12,r9,r12
8000227e:	f1 4c 00 44 	st.w	r8[68],r12
	gpio_port->gpers = 1 << (pin & 0x1F);
80002282:	91 1c       	st.w	r8[0x4],r12
}
80002284:	5e fc       	retal	r12
80002286:	d7 03       	nop

80002288 <led_timer_toggle_leds>:

void led_timer_toggle_leds(void)
{
80002288:	eb cd 40 c0 	pushm	r6-r7,lr
	led_timer_should_toggle_leds = 0;
8000228c:	30 07       	mov	r7,0
8000228e:	48 c8       	lddpc	r8,800022bc <led_timer_toggle_leds+0x34>
80002290:	b0 87       	st.b	r8[0x0],r7
	led_state ^= 1;
80002292:	48 c8       	lddpc	r8,800022c0 <led_timer_toggle_leds+0x38>
80002294:	11 86       	ld.ub	r6,r8[0x0]
80002296:	ec 16 00 01 	eorl	r6,0x1
8000229a:	b0 86       	st.b	r8[0x0],r6
	
	led_gpio_assign_pin(LED0_GPIO, led_state);
8000229c:	0c 9b       	mov	r11,r6
8000229e:	33 bc       	mov	r12,59
800022a0:	f0 1f 00 09 	mcall	800022c4 <led_timer_toggle_leds+0x3c>
	//if the led2 needs to be flashing...
	if (led_timer_flash_led2)
800022a4:	48 98       	lddpc	r8,800022c8 <led_timer_toggle_leds+0x40>
800022a6:	11 88       	ld.ub	r8,r8[0x0]
800022a8:	ee 08 18 00 	cp.b	r8,r7
800022ac:	c0 50       	breq	800022b6 <led_timer_toggle_leds+0x2e>
	{
		led_gpio_assign_pin(LED1_GPIO, led_state);
800022ae:	0c 9b       	mov	r11,r6
800022b0:	33 cc       	mov	r12,60
800022b2:	f0 1f 00 05 	mcall	800022c4 <led_timer_toggle_leds+0x3c>
800022b6:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800022ba:	00 00       	add	r0,r0
800022bc:	00 00       	add	r0,r0
800022be:	00 32       	cp.w	r2,r0
800022c0:	00 00       	add	r0,r0
800022c2:	00 29       	rsub	r9,r0
800022c4:	80 00       	ld.sh	r0,r0[0x0]
800022c6:	22 54       	sub	r4,37
800022c8:	00 00       	add	r0,r0
800022ca:	00 33       	cp.w	r3,r0

800022cc <uart_send_byte>:
	sampling_timer_is_sampling_ready = 0;
}

void uart_send_byte(uint8_t byte)
{
	uart_transmission_completed = 0;
800022cc:	30 09       	mov	r9,0
800022ce:	48 58       	lddpc	r8,800022e0 <uart_send_byte+0x14>
800022d0:	b0 89       	st.b	r8[0x0],r9
	AVR32_USART0.thr = (byte << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
800022d2:	fe 78 14 00 	mov	r8,-60416
800022d6:	91 7c       	st.w	r8[0x1c],r12
	AVR32_USART0.ier = AVR32_USART_IER_TXRDY_MASK;
800022d8:	30 29       	mov	r9,2
800022da:	91 29       	st.w	r8[0x8],r9
}
800022dc:	5e fc       	retal	r12
800022de:	00 00       	add	r0,r0
800022e0:	00 00       	add	r0,r0
800022e2:	00 35       	cp.w	r5,r0

800022e4 <uart_initialize>:
	
	tc_configure_interrupts(&AVR32_TC, SAMPLING_TIMER_CHANNEL, &sampling_timer_interrupts);
}

void uart_initialize(void)
{
800022e4:	d4 01       	pushm	lr
	uart_transmission_completed = 1;
800022e6:	30 19       	mov	r9,1
800022e8:	48 d8       	lddpc	r8,8000231c <uart_initialize+0x38>
800022ea:	b0 89       	st.b	r8[0x0],r9
	gpio_enable_module(usart_gpio_map, sizeof(usart_gpio_map) / sizeof(usart_gpio_map[0]));
800022ec:	30 2b       	mov	r11,2
800022ee:	48 dc       	lddpc	r12,80002320 <uart_initialize+0x3c>
800022f0:	f0 1f 00 0d 	mcall	80002324 <uart_initialize+0x40>
	usart_init_rs232(&AVR32_USART0, &options, FOSC0);
800022f4:	e0 6a 1b 00 	mov	r10,6912
800022f8:	ea 1a 00 b7 	orh	r10,0xb7
800022fc:	48 bb       	lddpc	r11,80002328 <uart_initialize+0x44>
800022fe:	fe 7c 14 00 	mov	r12,-60416
80002302:	f0 1f 00 0b 	mcall	8000232c <uart_initialize+0x48>
	AVR32_USART0.ier = AVR32_USART_IER_RXRDY_MASK;
80002306:	30 19       	mov	r9,1
80002308:	fe 78 14 00 	mov	r8,-60416
8000230c:	91 29       	st.w	r8[0x8],r9
	INTC_register_interrupt(&usart_irq_handler, AVR32_USART0_IRQ, AVR32_INTC_INT0);
8000230e:	30 0a       	mov	r10,0
80002310:	e0 6b 00 a0 	mov	r11,160
80002314:	48 7c       	lddpc	r12,80002330 <uart_initialize+0x4c>
80002316:	f0 1f 00 08 	mcall	80002334 <uart_initialize+0x50>
}
8000231a:	d8 02       	popm	pc
8000231c:	00 00       	add	r0,r0
8000231e:	00 35       	cp.w	r5,r0
80002320:	80 00       	ld.sh	r0,r0[0x0]
80002322:	30 20       	mov	r0,2
80002324:	80 00       	ld.sh	r0,r0[0x0]
80002326:	28 14       	sub	r4,-127
80002328:	80 00       	ld.sh	r0,r0[0x0]
8000232a:	30 00       	mov	r0,0
8000232c:	80 00       	ld.sh	r0,r0[0x0]
8000232e:	2b 20       	sub	r0,-78
80002330:	80 00       	ld.sh	r0,r0[0x0]
80002332:	22 18       	sub	r8,33
80002334:	80 00       	ld.sh	r0,r0[0x0]
80002336:	28 d4       	sub	r4,-115

80002338 <sampling_timer_irq_handler>:
	gpio_clear_pin_interrupt_flag(GPIO_PUSH_BUTTON_0);
}

__attribute__((__interrupt__))
static void sampling_timer_irq_handler(void)
{
80002338:	d4 01       	pushm	lr
	tc_read_sr(&AVR32_TC, SAMPLING_TIMER_CHANNEL);
8000233a:	30 0b       	mov	r11,0
8000233c:	fe 7c 38 00 	mov	r12,-51200
80002340:	f0 1f 00 04 	mcall	80002350 <sampling_timer_irq_handler+0x18>
	sampling_timer_is_sampling_ready = 1;
80002344:	30 19       	mov	r9,1
80002346:	48 48       	lddpc	r8,80002354 <sampling_timer_irq_handler+0x1c>
80002348:	b0 89       	st.b	r8[0x0],r9
}
8000234a:	d4 02       	popm	lr
8000234c:	d6 03       	rete
8000234e:	00 00       	add	r0,r0
80002350:	80 00       	ld.sh	r0,r0[0x0]
80002352:	20 c8       	sub	r8,12
80002354:	00 00       	add	r0,r0
80002356:	00 18       	sub	r8,r0

80002358 <led_timer_irq_handler>:
	(void)AVR32_ADC.lcdr;
}

__attribute__((__interrupt__))
void led_timer_irq_handler(void)
{
80002358:	d4 01       	pushm	lr
	static uint8_t ticks = 0;
	
	tc_read_sr(&AVR32_TC, LED_TIMER_CHANNEL);
8000235a:	30 1b       	mov	r11,1
8000235c:	fe 7c 38 00 	mov	r12,-51200
80002360:	f0 1f 00 09 	mcall	80002384 <led_timer_irq_handler+0x2c>
	
	ticks++;
80002364:	48 99       	lddpc	r9,80002388 <led_timer_irq_handler+0x30>
80002366:	13 88       	ld.ub	r8,r9[0x0]
80002368:	2f f8       	sub	r8,-1
8000236a:	b2 88       	st.b	r9[0x0],r8
	if (ticks == 10)
8000236c:	30 a9       	mov	r9,10
8000236e:	f2 08 18 00 	cp.b	r8,r9
80002372:	c0 71       	brne	80002380 <led_timer_irq_handler+0x28>
	{
		ticks = 0;
80002374:	30 09       	mov	r9,0
80002376:	48 58       	lddpc	r8,80002388 <led_timer_irq_handler+0x30>
80002378:	b0 89       	st.b	r8[0x0],r9
		led_timer_should_toggle_leds = 1;
8000237a:	30 19       	mov	r9,1
8000237c:	48 48       	lddpc	r8,8000238c <led_timer_irq_handler+0x34>
8000237e:	b0 89       	st.b	r8[0x0],r9
	}
}
80002380:	d4 02       	popm	lr
80002382:	d6 03       	rete
80002384:	80 00       	ld.sh	r0,r0[0x0]
80002386:	20 c8       	sub	r8,12
80002388:	00 00       	add	r0,r0
8000238a:	00 1c       	sub	r12,r0
8000238c:	00 00       	add	r0,r0
8000238e:	00 32       	cp.w	r2,r0

80002390 <frequency_button_initialize>:
	INTC_register_interrupt(&led_timer_irq_handler, LED_TIMER_IRQ, AVR32_INTC_INT0);
	tc_start(&AVR32_TC, led_timer_waveform.channel);
}

void frequency_button_initialize(void)
{
80002390:	d4 01       	pushm	lr
	gpio_enable_pin_interrupt(GPIO_PUSH_BUTTON_0, GPIO_RISING_EDGE);
80002392:	30 1b       	mov	r11,1
80002394:	35 8c       	mov	r12,88
80002396:	f0 1f 00 06 	mcall	800023ac <frequency_button_initialize+0x1c>
	gpio_enable_pin_glitch_filter(GPIO_PUSH_BUTTON_0);
8000239a:	35 8c       	mov	r12,88
8000239c:	f0 1f 00 05 	mcall	800023b0 <frequency_button_initialize+0x20>
	
	unsigned irq = AVR32_GPIO_IRQ_0 + GPIO_PUSH_BUTTON_0 / 8;
	INTC_register_interrupt(&frequency_button_pushed_irq_handler, irq, AVR32_INTC_INT0);
800023a0:	30 0a       	mov	r10,0
800023a2:	34 bb       	mov	r11,75
800023a4:	48 4c       	lddpc	r12,800023b4 <frequency_button_initialize+0x24>
800023a6:	f0 1f 00 05 	mcall	800023b8 <frequency_button_initialize+0x28>
}
800023aa:	d8 02       	popm	pc
800023ac:	80 00       	ld.sh	r0,r0[0x0]
800023ae:	28 76       	sub	r6,-121
800023b0:	80 00       	ld.sh	r0,r0[0x0]
800023b2:	28 60       	sub	r0,-122
800023b4:	80 00       	ld.sh	r0,r0[0x0]
800023b6:	23 bc       	sub	r12,59
800023b8:	80 00       	ld.sh	r0,r0[0x0]
800023ba:	28 d4       	sub	r4,-115

800023bc <frequency_button_pushed_irq_handler>:
	}
}

__attribute__((__interrupt__))
static void frequency_button_pushed_irq_handler(void)
{
800023bc:	d4 01       	pushm	lr
	switch (sampling_timer_current_frequency)
800023be:	48 e8       	lddpc	r8,800023f4 <frequency_button_pushed_irq_handler+0x38>
800023c0:	90 08       	ld.sh	r8,r8[0x0]
800023c2:	e0 69 03 e8 	mov	r9,1000
800023c6:	f2 08 19 00 	cp.h	r8,r9
800023ca:	c0 70       	breq	800023d8 <frequency_button_pushed_irq_handler+0x1c>
800023cc:	e0 69 07 d0 	mov	r9,2000
800023d0:	f2 08 19 00 	cp.h	r8,r9
800023d4:	c0 b1       	brne	800023ea <frequency_button_pushed_irq_handler+0x2e>
800023d6:	c0 68       	rjmp	800023e2 <frequency_button_pushed_irq_handler+0x26>
	{
		// first frequency
		case 1000:
		sampling_timer_desired_frequency = 2000;
800023d8:	e0 69 07 d0 	mov	r9,2000
800023dc:	48 78       	lddpc	r8,800023f8 <frequency_button_pushed_irq_handler+0x3c>
800023de:	b0 09       	st.h	r8[0x0],r9
		break;
800023e0:	c0 58       	rjmp	800023ea <frequency_button_pushed_irq_handler+0x2e>
		
		// second frequency
		case 2000:
		sampling_timer_desired_frequency = 1000;
800023e2:	e0 69 03 e8 	mov	r9,1000
800023e6:	48 58       	lddpc	r8,800023f8 <frequency_button_pushed_irq_handler+0x3c>
800023e8:	b0 09       	st.h	r8[0x0],r9
		break;
	}
	
	//clear flag
	gpio_clear_pin_interrupt_flag(GPIO_PUSH_BUTTON_0);
800023ea:	35 8c       	mov	r12,88
800023ec:	f0 1f 00 04 	mcall	800023fc <frequency_button_pushed_irq_handler+0x40>
}
800023f0:	d4 02       	popm	lr
800023f2:	d6 03       	rete
800023f4:	00 00       	add	r0,r0
800023f6:	00 1a       	sub	r10,r0
800023f8:	00 00       	add	r0,r0
800023fa:	00 30       	cp.w	r0,r0
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	28 bc       	sub	r12,-117

80002400 <sampling_timer_set_frequency>:
		led_gpio_assign_pin(LED1_GPIO, led_state);
	}
}

void sampling_timer_set_frequency(uint16_t freq)
{
80002400:	eb cd 40 80 	pushm	r7,lr
80002404:	18 97       	mov	r7,r12
	tc_write_rc(&AVR32_TC, SAMPLING_TIMER_CHANNEL, SAMPLING_TIMER_TICKS_PER_SECOND / freq);
80002406:	18 9b       	mov	r11,r12
80002408:	5c 7b       	castu.h	r11
8000240a:	e0 68 e3 60 	mov	r8,58208
8000240e:	ea 18 00 16 	orh	r8,0x16
80002412:	f0 0b 0c 0a 	divs	r10,r8,r11
80002416:	5c 7a       	castu.h	r10
80002418:	30 0b       	mov	r11,0
8000241a:	fe 7c 38 00 	mov	r12,-51200
8000241e:	f0 1f 00 05 	mcall	80002430 <sampling_timer_set_frequency+0x30>
	sampling_timer_desired_frequency = freq;
80002422:	48 58       	lddpc	r8,80002434 <sampling_timer_set_frequency+0x34>
80002424:	b0 07       	st.h	r8[0x0],r7
	sampling_timer_current_frequency = freq;
80002426:	48 58       	lddpc	r8,80002438 <sampling_timer_set_frequency+0x38>
80002428:	b0 07       	st.h	r8[0x0],r7
}
8000242a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000242e:	00 00       	add	r0,r0
80002430:	80 00       	ld.sh	r0,r0[0x0]
80002432:	20 da       	sub	r10,13
80002434:	00 00       	add	r0,r0
80002436:	00 30       	cp.w	r0,r0
80002438:	00 00       	add	r0,r0
8000243a:	00 1a       	sub	r10,r0

8000243c <sampling_timer_initialize>:
	unsigned irq = AVR32_GPIO_IRQ_0 + GPIO_PUSH_BUTTON_0 / 8;
	INTC_register_interrupt(&frequency_button_pushed_irq_handler, irq, AVR32_INTC_INT0);
}

void sampling_timer_initialize()
{
8000243c:	d4 01       	pushm	lr
	tc_init_waveform(&AVR32_TC, &sampling_timer_waveform);
8000243e:	48 cb       	lddpc	r11,8000246c <sampling_timer_initialize+0x30>
80002440:	fe 7c 38 00 	mov	r12,-51200
80002444:	f0 1f 00 0b 	mcall	80002470 <sampling_timer_initialize+0x34>
	INTC_register_interrupt(&sampling_timer_irq_handler, SAMPLING_TIMER_IRQ, AVR32_INTC_INT2);
80002448:	30 2a       	mov	r10,2
8000244a:	e0 6b 01 c0 	mov	r11,448
8000244e:	48 ac       	lddpc	r12,80002474 <sampling_timer_initialize+0x38>
80002450:	f0 1f 00 0a 	mcall	80002478 <sampling_timer_initialize+0x3c>
	sampling_timer_set_frequency(1000);
80002454:	e0 6c 03 e8 	mov	r12,1000
80002458:	f0 1f 00 09 	mcall	8000247c <sampling_timer_initialize+0x40>
	
	tc_configure_interrupts(&AVR32_TC, SAMPLING_TIMER_CHANNEL, &sampling_timer_interrupts);
8000245c:	48 9a       	lddpc	r10,80002480 <sampling_timer_initialize+0x44>
8000245e:	30 0b       	mov	r11,0
80002460:	fe 7c 38 00 	mov	r12,-51200
80002464:	f0 1f 00 08 	mcall	80002484 <sampling_timer_initialize+0x48>
}
80002468:	d8 02       	popm	pc
8000246a:	00 00       	add	r0,r0
8000246c:	00 00       	add	r0,r0
8000246e:	00 08       	add	r8,r0
80002470:	80 00       	ld.sh	r0,r0[0x0]
80002472:	20 08       	sub	r8,0
80002474:	80 00       	ld.sh	r0,r0[0x0]
80002476:	23 38       	sub	r8,51
80002478:	80 00       	ld.sh	r0,r0[0x0]
8000247a:	28 d4       	sub	r4,-115
8000247c:	80 00       	ld.sh	r0,r0[0x0]
8000247e:	24 00       	sub	r0,64
80002480:	80 00       	ld.sh	r0,r0[0x0]
80002482:	30 1c       	mov	r12,1
80002484:	80 00       	ld.sh	r0,r0[0x0]
80002486:	21 0e       	sub	lr,16

80002488 <led_timer_initialize>:
	adc_enable(&AVR32_ADC, ADC_POTENTIOMETER_CHANNEL);
	INTC_register_interrupt(&adc_conversion_handler, AVR32_ADC_IRQ, AVR32_INTC_INT3);
}

void led_timer_initialize(void)
{
80002488:	eb cd 40 80 	pushm	r7,lr
	tc_init_waveform(&AVR32_TC, &led_timer_waveform);
8000248c:	49 07       	lddpc	r7,800024cc <led_timer_initialize+0x44>
8000248e:	0e 9b       	mov	r11,r7
80002490:	fe 7c 38 00 	mov	r12,-51200
80002494:	f0 1f 00 0f 	mcall	800024d0 <led_timer_initialize+0x48>
	tc_write_rc(&AVR32_TC, LED_TIMER_CHANNEL, LED_TIMER_TICKS_PER_SECOND / 50);
80002498:	e0 6a 07 53 	mov	r10,1875
8000249c:	30 1b       	mov	r11,1
8000249e:	fe 7c 38 00 	mov	r12,-51200
800024a2:	f0 1f 00 0d 	mcall	800024d4 <led_timer_initialize+0x4c>
	tc_configure_interrupts(&AVR32_TC, LED_TIMER_CHANNEL, &led_timer_interrupts);
800024a6:	48 da       	lddpc	r10,800024d8 <led_timer_initialize+0x50>
800024a8:	30 1b       	mov	r11,1
800024aa:	fe 7c 38 00 	mov	r12,-51200
800024ae:	f0 1f 00 0c 	mcall	800024dc <led_timer_initialize+0x54>
	INTC_register_interrupt(&led_timer_irq_handler, LED_TIMER_IRQ, AVR32_INTC_INT0);
800024b2:	30 0a       	mov	r10,0
800024b4:	e0 6b 01 c1 	mov	r11,449
800024b8:	48 ac       	lddpc	r12,800024e0 <led_timer_initialize+0x58>
800024ba:	f0 1f 00 0b 	mcall	800024e4 <led_timer_initialize+0x5c>
	tc_start(&AVR32_TC, led_timer_waveform.channel);
800024be:	6e 0b       	ld.w	r11,r7[0x0]
800024c0:	fe 7c 38 00 	mov	r12,-51200
800024c4:	f0 1f 00 09 	mcall	800024e8 <led_timer_initialize+0x60>
}
800024c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800024cc:	00 00       	add	r0,r0
800024ce:	00 10       	sub	r0,r0
800024d0:	80 00       	ld.sh	r0,r0[0x0]
800024d2:	20 08       	sub	r8,0
800024d4:	80 00       	ld.sh	r0,r0[0x0]
800024d6:	20 da       	sub	r10,13
800024d8:	80 00       	ld.sh	r0,r0[0x0]
800024da:	30 30       	mov	r0,3
800024dc:	80 00       	ld.sh	r0,r0[0x0]
800024de:	21 0e       	sub	lr,16
800024e0:	80 00       	ld.sh	r0,r0[0x0]
800024e2:	23 58       	sub	r8,53
800024e4:	80 00       	ld.sh	r0,r0[0x0]
800024e6:	28 d4       	sub	r4,-115
800024e8:	80 00       	ld.sh	r0,r0[0x0]
800024ea:	20 a4       	sub	r4,10

800024ec <sampling_timer_start>:
	sampling_timer_desired_frequency = freq;
	sampling_timer_current_frequency = freq;
}

void sampling_timer_start(void)
{
800024ec:	d4 01       	pushm	lr
	tc_start(&AVR32_TC, sampling_timer_waveform.channel);
800024ee:	48 78       	lddpc	r8,80002508 <sampling_timer_start+0x1c>
800024f0:	70 0b       	ld.w	r11,r8[0x0]
800024f2:	fe 7c 38 00 	mov	r12,-51200
800024f6:	f0 1f 00 06 	mcall	8000250c <sampling_timer_start+0x20>
	sampling_timer_is_running = 1;
800024fa:	30 18       	mov	r8,1
800024fc:	48 59       	lddpc	r9,80002510 <sampling_timer_start+0x24>
800024fe:	b2 88       	st.b	r9[0x0],r8
	led_timer_flash_led2 = 1;
80002500:	48 59       	lddpc	r9,80002514 <sampling_timer_start+0x28>
80002502:	b2 88       	st.b	r9[0x0],r8
}
80002504:	d8 02       	popm	pc
80002506:	00 00       	add	r0,r0
80002508:	00 00       	add	r0,r0
8000250a:	00 08       	add	r8,r0
8000250c:	80 00       	ld.sh	r0,r0[0x0]
8000250e:	20 a4       	sub	r4,10
80002510:	00 00       	add	r0,r0
80002512:	00 28       	rsub	r8,r0
80002514:	00 00       	add	r0,r0
80002516:	00 33       	cp.w	r3,r0

80002518 <adc_initialize>:
/*//////////////////////////////////////////////////////////
						INITS
*///////////////////////////////////////////////////////////

void adc_initialize(void)
{
80002518:	eb cd 40 80 	pushm	r7,lr
	{
		{ ADC_LIGHT_PIN, ADC_LIGHT_FUNCTION },
		{ ADC_POTENTIOMETER_PIN, ADC_POTENTIOMETER_FUNCTION }
	};

	gpio_enable_module(ADC_GPIO_MAP, COUNT(ADC_GPIO_MAP));
8000251c:	30 2b       	mov	r11,2
8000251e:	49 0c       	lddpc	r12,8000255c <adc_initialize+0x44>
80002520:	f0 1f 00 10 	mcall	80002560 <adc_initialize+0x48>

	AVR32_ADC.mr |= 0x1 << AVR32_ADC_MR_PRESCAL_OFFSET;
80002524:	fe 77 3c 00 	mov	r7,-50176
80002528:	6e 18       	ld.w	r8,r7[0x4]
8000252a:	a9 a8       	sbr	r8,0x8
8000252c:	8f 18       	st.w	r7[0x4],r8
	AVR32_ADC.ier = AVR32_ADC_DRDY_MASK;
8000252e:	e0 78 00 00 	mov	r8,65536
80002532:	8f 98       	st.w	r7[0x24],r8
	adc_configure(&AVR32_ADC);
80002534:	0e 9c       	mov	r12,r7
80002536:	f0 1f 00 0c 	mcall	80002564 <adc_initialize+0x4c>

	adc_enable(&AVR32_ADC, ADC_LIGHT_CHANNEL);
8000253a:	30 2b       	mov	r11,2
8000253c:	0e 9c       	mov	r12,r7
8000253e:	f0 1f 00 0b 	mcall	80002568 <adc_initialize+0x50>
	adc_enable(&AVR32_ADC, ADC_POTENTIOMETER_CHANNEL);
80002542:	30 1b       	mov	r11,1
80002544:	0e 9c       	mov	r12,r7
80002546:	f0 1f 00 09 	mcall	80002568 <adc_initialize+0x50>
	INTC_register_interrupt(&adc_conversion_handler, AVR32_ADC_IRQ, AVR32_INTC_INT3);
8000254a:	30 3a       	mov	r10,3
8000254c:	e0 6b 01 e0 	mov	r11,480
80002550:	48 7c       	lddpc	r12,8000256c <adc_initialize+0x54>
80002552:	f0 1f 00 08 	mcall	80002570 <adc_initialize+0x58>
}
80002556:	e3 cd 80 80 	ldm	sp++,r7,pc
8000255a:	00 00       	add	r0,r0
8000255c:	80 00       	ld.sh	r0,r0[0x0]
8000255e:	30 0c       	mov	r12,0
80002560:	80 00       	ld.sh	r0,r0[0x0]
80002562:	28 14       	sub	r4,-127
80002564:	80 00       	ld.sh	r0,r0[0x0]
80002566:	27 64       	sub	r4,118
80002568:	80 00       	ld.sh	r0,r0[0x0]
8000256a:	27 7c       	sub	r12,119
8000256c:	80 00       	ld.sh	r0,r0[0x0]
8000256e:	25 74       	sub	r4,87
80002570:	80 00       	ld.sh	r0,r0[0x0]
80002572:	28 d4       	sub	r4,-115

80002574 <adc_conversion_handler>:
						INTURUPTS 
*///////////////////////////////////////////////////////////

__attribute__((__interrupt__))
static void adc_conversion_handler(void)
{
80002574:	d4 01       	pushm	lr
	if (adc_check_eoc(&AVR32_ADC, ADC_POTENTIOMETER_CHANNEL))
80002576:	30 1b       	mov	r11,1
80002578:	fe 7c 3c 00 	mov	r12,-50176
8000257c:	f0 1f 00 12 	mcall	800025c4 <adc_conversion_handler+0x50>
80002580:	c0 c0       	breq	80002598 <adc_conversion_handler+0x24>
	{
		// conversion for potentiometer 
		adc_conversion_indices[0]++;
80002582:	49 28       	lddpc	r8,800025c8 <adc_conversion_handler+0x54>
80002584:	11 89       	ld.ub	r9,r8[0x0]
80002586:	2f f9       	sub	r9,-1
80002588:	b0 89       	st.b	r8[0x0],r9
		adc_conversion_values[0] = adc_get_value(&AVR32_ADC, ADC_POTENTIOMETER_CHANNEL);
8000258a:	30 1b       	mov	r11,1
8000258c:	fe 7c 3c 00 	mov	r12,-50176
80002590:	f0 1f 00 0f 	mcall	800025cc <adc_conversion_handler+0x58>
80002594:	48 f8       	lddpc	r8,800025d0 <adc_conversion_handler+0x5c>
80002596:	91 0c       	st.w	r8[0x0],r12
	}
	
	if (adc_check_eoc(&AVR32_ADC, ADC_LIGHT_CHANNEL))
80002598:	30 2b       	mov	r11,2
8000259a:	fe 7c 3c 00 	mov	r12,-50176
8000259e:	f0 1f 00 0a 	mcall	800025c4 <adc_conversion_handler+0x50>
800025a2:	c0 c0       	breq	800025ba <adc_conversion_handler+0x46>
	{
		// conversion for light sensor
		adc_conversion_indices[1]++;
800025a4:	48 98       	lddpc	r8,800025c8 <adc_conversion_handler+0x54>
800025a6:	11 99       	ld.ub	r9,r8[0x1]
800025a8:	2f f9       	sub	r9,-1
800025aa:	b0 99       	st.b	r8[0x1],r9
		adc_conversion_values[1] = adc_get_value(&AVR32_ADC, ADC_LIGHT_CHANNEL);
800025ac:	30 2b       	mov	r11,2
800025ae:	fe 7c 3c 00 	mov	r12,-50176
800025b2:	f0 1f 00 07 	mcall	800025cc <adc_conversion_handler+0x58>
800025b6:	48 78       	lddpc	r8,800025d0 <adc_conversion_handler+0x5c>
800025b8:	91 1c       	st.w	r8[0x4],r12
	}
	
	(void)AVR32_ADC.lcdr;
800025ba:	fe 78 3c 00 	mov	r8,-50176
800025be:	70 88       	ld.w	r8,r8[0x20]
}
800025c0:	d4 02       	popm	lr
800025c2:	d6 03       	rete
800025c4:	80 00       	ld.sh	r0,r0[0x0]
800025c6:	27 86       	sub	r6,120
800025c8:	00 00       	add	r0,r0
800025ca:	00 2c       	rsub	r12,r0
800025cc:	80 00       	ld.sh	r0,r0[0x0]
800025ce:	27 98       	sub	r8,121
800025d0:	00 00       	add	r0,r0
800025d2:	00 20       	rsub	r0,r0

800025d4 <sampling_timer_start_sampling>:
	led_timer_flash_led2 = 0;
	gpio_set_gpio_pin(LED1_GPIO);
}

void sampling_timer_start_sampling()
{
800025d4:	d4 01       	pushm	lr
	adc_start(&AVR32_ADC);
800025d6:	fe 7c 3c 00 	mov	r12,-50176
800025da:	f0 1f 00 04 	mcall	800025e8 <sampling_timer_start_sampling+0x14>
	sampling_timer_is_sampling_ready = 0;
800025de:	30 09       	mov	r9,0
800025e0:	48 38       	lddpc	r8,800025ec <sampling_timer_start_sampling+0x18>
800025e2:	b0 89       	st.b	r8[0x0],r9
}
800025e4:	d8 02       	popm	pc
800025e6:	00 00       	add	r0,r0
800025e8:	80 00       	ld.sh	r0,r0[0x0]
800025ea:	27 76       	sub	r6,119
800025ec:	00 00       	add	r0,r0
800025ee:	00 18       	sub	r8,r0

800025f0 <sampling_timer_stop>:
	sampling_timer_is_running = 1;
	led_timer_flash_led2 = 1;
}

void sampling_timer_stop(void)
{
800025f0:	d4 01       	pushm	lr
	tc_stop(&AVR32_TC, sampling_timer_waveform.channel);
800025f2:	48 88       	lddpc	r8,80002610 <sampling_timer_stop+0x20>
800025f4:	70 0b       	ld.w	r11,r8[0x0]
800025f6:	fe 7c 38 00 	mov	r12,-51200
800025fa:	f0 1f 00 07 	mcall	80002614 <sampling_timer_stop+0x24>
	sampling_timer_is_running = 0;
800025fe:	30 08       	mov	r8,0
80002600:	48 69       	lddpc	r9,80002618 <sampling_timer_stop+0x28>
80002602:	b2 88       	st.b	r9[0x0],r8
	led_timer_flash_led2 = 0;
80002604:	48 69       	lddpc	r9,8000261c <sampling_timer_stop+0x2c>
80002606:	b2 88       	st.b	r9[0x0],r8
	gpio_set_gpio_pin(LED1_GPIO);
80002608:	33 cc       	mov	r12,60
8000260a:	f0 1f 00 06 	mcall	80002620 <sampling_timer_stop+0x30>
}
8000260e:	d8 02       	popm	pc
80002610:	00 00       	add	r0,r0
80002612:	00 08       	add	r8,r0
80002614:	80 00       	ld.sh	r0,r0[0x0]
80002616:	20 b6       	sub	r6,11
80002618:	00 00       	add	r0,r0
8000261a:	00 28       	rsub	r8,r0
8000261c:	00 00       	add	r0,r0
8000261e:	00 33       	cp.w	r3,r0
80002620:	80 00       	ld.sh	r0,r0[0x0]
80002622:	28 44       	sub	r4,-124

80002624 <main>:
/*//////////////////////////////////////////////////////////
						MAIN 
*///////////////////////////////////////////////////////////

int main(void)
{
80002624:	d4 31       	pushm	r0-r7,lr
80002626:	20 1d       	sub	sp,4
	pm_switch_to_osc0(&AVR32_PM, FOSC0, OSC0_STARTUP);
80002628:	30 3a       	mov	r10,3
8000262a:	e0 6b 1b 00 	mov	r11,6912
8000262e:	ea 1b 00 b7 	orh	r11,0xb7
80002632:	fe 7c 0c 00 	mov	r12,-62464
80002636:	f0 1f 00 36 	mcall	8000270c <main+0xe8>
	
	Disable_global_interrupt();
8000263a:	d3 03       	ssrf	0x10
	{
		INTC_init_interrupts();
8000263c:	f0 1f 00 35 	mcall	80002710 <main+0xec>
		
		adc_initialize();
80002640:	f0 1f 00 35 	mcall	80002714 <main+0xf0>
		sampling_timer_initialize();
80002644:	f0 1f 00 35 	mcall	80002718 <main+0xf4>
		led_timer_initialize();
80002648:	f0 1f 00 35 	mcall	8000271c <main+0xf8>
		frequency_button_initialize();
8000264c:	f0 1f 00 35 	mcall	80002720 <main+0xfc>
		uart_initialize();
80002650:	f0 1f 00 35 	mcall	80002724 <main+0x100>
	}
	Enable_global_interrupt();
80002654:	d5 03       	csrf	0x10

	uint8_t last_conversions[2] = {0, 0};
80002656:	30 08       	mov	r8,0
80002658:	ba 88       	st.b	sp[0x0],r8
8000265a:	ba 98       	st.b	sp[0x1],r8
	while (1)
	{
		if (uart_received_command != 0)
8000265c:	4b 37       	lddpc	r7,80002728 <main+0x104>
		{
			if (uart_received_command == 's')
8000265e:	37 32       	mov	r2,115
			}
			else if (uart_received_command == 'x')
			{
				sampling_timer_stop();
			}
			uart_received_command = 0;
80002660:	10 91       	mov	r1,r8
	Enable_global_interrupt();

	uint8_t last_conversions[2] = {0, 0};
	while (1)
	{
		if (uart_received_command != 0)
80002662:	0f 88       	ld.ub	r8,r7[0x0]
80002664:	58 08       	cp.w	r8,0
80002666:	c1 00       	breq	80002686 <main+0x62>
		{
			if (uart_received_command == 's')
80002668:	0f 88       	ld.ub	r8,r7[0x0]
8000266a:	e4 08 18 00 	cp.b	r8,r2
8000266e:	c0 41       	brne	80002676 <main+0x52>
			{
				sampling_timer_start();
80002670:	f0 1f 00 2f 	mcall	8000272c <main+0x108>
80002674:	c0 88       	rjmp	80002684 <main+0x60>
			}
			else if (uart_received_command == 'x')
80002676:	0f 89       	ld.ub	r9,r7[0x0]
80002678:	37 88       	mov	r8,120
8000267a:	f0 09 18 00 	cp.b	r9,r8
8000267e:	c0 31       	brne	80002684 <main+0x60>
			{
				sampling_timer_stop();
80002680:	f0 1f 00 2c 	mcall	80002730 <main+0x10c>
			}
			uart_received_command = 0;
80002684:	ae 81       	st.b	r7[0x0],r1
		}
		
		if (sampling_timer_desired_frequency != sampling_timer_current_frequency)
80002686:	4a c8       	lddpc	r8,80002734 <main+0x110>
80002688:	90 08       	ld.sh	r8,r8[0x0]
8000268a:	4a c9       	lddpc	r9,80002738 <main+0x114>
8000268c:	92 09       	ld.sh	r9,r9[0x0]
8000268e:	f0 09 19 00 	cp.h	r9,r8
80002692:	c0 60       	breq	8000269e <main+0x7a>
		{
			sampling_timer_set_frequency(sampling_timer_desired_frequency);
80002694:	4a 88       	lddpc	r8,80002734 <main+0x110>
80002696:	90 0c       	ld.sh	r12,r8[0x0]
80002698:	5c 7c       	castu.h	r12
8000269a:	f0 1f 00 29 	mcall	8000273c <main+0x118>
		}
		
		if (led_timer_should_toggle_leds)
8000269e:	4a 98       	lddpc	r8,80002740 <main+0x11c>
800026a0:	11 88       	ld.ub	r8,r8[0x0]
800026a2:	58 08       	cp.w	r8,0
800026a4:	c0 30       	breq	800026aa <main+0x86>
		{
			led_timer_toggle_leds();
800026a6:	f0 1f 00 28 	mcall	80002744 <main+0x120>
		}
		
		if (sampling_timer_is_sampling_ready)
800026aa:	4a 88       	lddpc	r8,80002748 <main+0x124>
800026ac:	11 88       	ld.ub	r8,r8[0x0]
800026ae:	58 08       	cp.w	r8,0
800026b0:	c0 30       	breq	800026b6 <main+0x92>
		{
			sampling_timer_start_sampling();
800026b2:	f0 1f 00 27 	mcall	8000274c <main+0x128>
800026b6:	1a 95       	mov	r5,sp
800026b8:	30 06       	mov	r6,0
					uint8_t byte = ((adc_conversion_values[i] & 0b1111111000) >> 2) | i;
					uart_send_byte(byte);
				}
				else{
					//something went wrong light up led4
					gpio_set_gpio_pin(LED4_GPIO);	
800026ba:	33 33       	mov	r3,51
			if (last_conversions[i] != index)
			{
				if ((uint8_t)(last_conversions[i] + 1) != index)
				{
					// something went wrong light up led3
					gpio_set_gpio_pin(LED3_GPIO);
800026bc:	33 e4       	mov	r4,62
			sampling_timer_start_sampling();
		}
		
		for (int i = 0; i < 2; i++)
		{
			uint8_t index = adc_conversion_indices[i];
800026be:	4a 59       	lddpc	r9,80002750 <main+0x12c>
800026c0:	f2 06 07 00 	ld.ub	r0,r9[r6]
			if (last_conversions[i] != index)
800026c4:	0b 88       	ld.ub	r8,r5[0x0]
800026c6:	e0 08 18 00 	cp.b	r8,r0
800026ca:	c1 b0       	breq	80002700 <main+0xdc>
			{
				if ((uint8_t)(last_conversions[i] + 1) != index)
800026cc:	2f f8       	sub	r8,-1
800026ce:	e0 08 18 00 	cp.b	r8,r0
800026d2:	c0 40       	breq	800026da <main+0xb6>
				{
					// something went wrong light up led3
					gpio_set_gpio_pin(LED3_GPIO);
800026d4:	08 9c       	mov	r12,r4
800026d6:	f0 1f 00 20 	mcall	80002754 <main+0x130>
				}
				
				if (uart_transmission_completed)
800026da:	4a 09       	lddpc	r9,80002758 <main+0x134>
800026dc:	13 88       	ld.ub	r8,r9[0x0]
800026de:	58 08       	cp.w	r8,0
800026e0:	c0 d0       	breq	800026fa <main+0xd6>
				{
					last_conversions[i] = index;
800026e2:	aa 80       	st.b	r5[0x0],r0
					uint8_t byte = ((adc_conversion_values[i] & 0b1111111000) >> 2) | i;
800026e4:	49 e8       	lddpc	r8,8000275c <main+0x138>
800026e6:	f0 06 03 2c 	ld.w	r12,r8[r6<<0x2]
					uart_send_byte(byte);
800026ea:	e2 1c 03 f8 	andl	r12,0x3f8,COH
800026ee:	ed ec 12 2c 	or	r12,r6,r12>>0x2
800026f2:	5c 5c       	castu.b	r12
800026f4:	f0 1f 00 1b 	mcall	80002760 <main+0x13c>
800026f8:	c0 48       	rjmp	80002700 <main+0xdc>
				}
				else{
					//something went wrong light up led4
					gpio_set_gpio_pin(LED4_GPIO);	
800026fa:	06 9c       	mov	r12,r3
800026fc:	f0 1f 00 16 	mcall	80002754 <main+0x130>
		if (sampling_timer_is_sampling_ready)
		{
			sampling_timer_start_sampling();
		}
		
		for (int i = 0; i < 2; i++)
80002700:	2f f6       	sub	r6,-1
80002702:	2f f5       	sub	r5,-1
80002704:	58 26       	cp.w	r6,2
80002706:	ca e0       	breq	80002662 <main+0x3e>
80002708:	cd bb       	rjmp	800026be <main+0x9a>
8000270a:	00 00       	add	r0,r0
8000270c:	80 00       	ld.sh	r0,r0[0x0]
8000270e:	2a 6c       	sub	r12,-90
80002710:	80 00       	ld.sh	r0,r0[0x0]
80002712:	29 54       	sub	r4,-107
80002714:	80 00       	ld.sh	r0,r0[0x0]
80002716:	25 18       	sub	r8,81
80002718:	80 00       	ld.sh	r0,r0[0x0]
8000271a:	24 3c       	sub	r12,67
8000271c:	80 00       	ld.sh	r0,r0[0x0]
8000271e:	24 88       	sub	r8,72
80002720:	80 00       	ld.sh	r0,r0[0x0]
80002722:	23 90       	sub	r0,57
80002724:	80 00       	ld.sh	r0,r0[0x0]
80002726:	22 e4       	sub	r4,46
80002728:	00 00       	add	r0,r0
8000272a:	00 34       	cp.w	r4,r0
8000272c:	80 00       	ld.sh	r0,r0[0x0]
8000272e:	24 ec       	sub	r12,78
80002730:	80 00       	ld.sh	r0,r0[0x0]
80002732:	25 f0       	sub	r0,95
80002734:	00 00       	add	r0,r0
80002736:	00 30       	cp.w	r0,r0
80002738:	00 00       	add	r0,r0
8000273a:	00 1a       	sub	r10,r0
8000273c:	80 00       	ld.sh	r0,r0[0x0]
8000273e:	24 00       	sub	r0,64
80002740:	00 00       	add	r0,r0
80002742:	00 32       	cp.w	r2,r0
80002744:	80 00       	ld.sh	r0,r0[0x0]
80002746:	22 88       	sub	r8,40
80002748:	00 00       	add	r0,r0
8000274a:	00 18       	sub	r8,r0
8000274c:	80 00       	ld.sh	r0,r0[0x0]
8000274e:	25 d4       	sub	r4,93
80002750:	00 00       	add	r0,r0
80002752:	00 2c       	rsub	r12,r0
80002754:	80 00       	ld.sh	r0,r0[0x0]
80002756:	28 44       	sub	r4,-124
80002758:	00 00       	add	r0,r0
8000275a:	00 35       	cp.w	r5,r0
8000275c:	00 00       	add	r0,r0
8000275e:	00 20       	rsub	r0,r0
80002760:	80 00       	ld.sh	r0,r0[0x0]
80002762:	22 cc       	sub	r12,44

80002764 <adc_configure>:
	adc->mr |= 1 << AVR32_ADC_LOWRES_OFFSET;
#endif

	/* Set Sample/Hold time to max so that the ADC capacitor should be
	 * loaded entirely */
	adc->mr |= 0xF << AVR32_ADC_SHTIM_OFFSET;
80002764:	78 18       	ld.w	r8,r12[0x4]
80002766:	ea 18 0f 00 	orh	r8,0xf00
8000276a:	99 18       	st.w	r12[0x4],r8

	/* Set Startup to max so that the ADC capacitor should be loaded
	 * entirely */
	adc->mr |= 0x1F << AVR32_ADC_STARTUP_OFFSET;
8000276c:	78 18       	ld.w	r8,r12[0x4]
8000276e:	ea 18 00 1f 	orh	r8,0x1f
80002772:	99 18       	st.w	r12[0x4],r8
}
80002774:	5e fc       	retal	r12

80002776 <adc_start>:
void adc_start(volatile avr32_adc_t *adc)
{
	Assert( adc != NULL );

	/* start conversion */
	adc->cr = AVR32_ADC_START_MASK;
80002776:	30 28       	mov	r8,2
80002778:	99 08       	st.w	r12[0x0],r8
}
8000277a:	5e fc       	retal	r12

8000277c <adc_enable>:
	Assert( adc != NULL );
	Assert( channel <= AVR32_ADC_CHANNELS_MSB ); /* check if channel exist
	                                              **/

	/* enable channel */
	adc->cher = (1 << channel);
8000277c:	30 18       	mov	r8,1
8000277e:	f0 0b 09 48 	lsl	r8,r8,r11
80002782:	99 48       	st.w	r12[0x10],r8
}
80002784:	5e fc       	retal	r12

80002786 <adc_check_eoc>:
	Assert( adc != NULL );
	Assert( channel <= AVR32_ADC_CHANNELS_MSB ); /* check if channel exist
	                                              **/

	/* get SR register : EOC bit for channel */
	return ((adc->sr & (1 << channel)) ? true : false);
80002786:	78 78       	ld.w	r8,r12[0x1c]
80002788:	30 19       	mov	r9,1
8000278a:	f2 0b 09 49 	lsl	r9,r9,r11
8000278e:	f3 e8 00 08 	and	r8,r9,r8
}
80002792:	5f 1c       	srne	r12
80002794:	5e fc       	retal	r12
80002796:	d7 03       	nop

80002798 <adc_get_value>:
 * \param *adc Base address of the ADC
 * \param  channel   channel to handle (0 to 7)
 * \return The value acquired (unsigned long)
 */
uint32_t adc_get_value(volatile avr32_adc_t *adc, uint16_t channel)
{
80002798:	eb cd 40 e0 	pushm	r5-r7,lr
8000279c:	18 97       	mov	r7,r12
8000279e:	16 95       	mov	r5,r11
	Assert( adc != NULL );
	Assert( channel <= AVR32_ADC_CHANNELS_MSB );

	/* wait for end of conversion */
	while (adc_check_eoc(adc, channel) != true) {
800027a0:	ed db c0 10 	bfextu	r6,r11,0x0,0x10
800027a4:	0c 9b       	mov	r11,r6
800027a6:	0e 9c       	mov	r12,r7
800027a8:	f0 1f 00 05 	mcall	800027bc <adc_get_value+0x24>
800027ac:	cf c0       	breq	800027a4 <adc_get_value+0xc>
	}

	return *((uint32_t *)((&(adc->cdr0)) + channel));
800027ae:	2d 07       	sub	r7,-48
800027b0:	5c 75       	castu.h	r5
}
800027b2:	ee 05 03 2c 	ld.w	r12,r7[r5<<0x2]
800027b6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800027ba:	00 00       	add	r0,r0
800027bc:	80 00       	ld.sh	r0,r0[0x0]
800027be:	27 86       	sub	r6,120

800027c0 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800027c0:	f8 08 16 05 	lsr	r8,r12,0x5
800027c4:	a9 68       	lsl	r8,0x8
800027c6:	e0 28 f0 00 	sub	r8,61440

	/* Enable the correct function. */
	switch (function) {
800027ca:	58 1b       	cp.w	r11,1
800027cc:	c0 d0       	breq	800027e6 <gpio_enable_module_pin+0x26>
800027ce:	c0 63       	brcs	800027da <gpio_enable_module_pin+0x1a>
800027d0:	58 2b       	cp.w	r11,2
800027d2:	c1 00       	breq	800027f2 <gpio_enable_module_pin+0x32>
800027d4:	58 3b       	cp.w	r11,3
800027d6:	c1 40       	breq	800027fe <gpio_enable_module_pin+0x3e>
800027d8:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800027da:	30 19       	mov	r9,1
800027dc:	f2 0c 09 49 	lsl	r9,r9,r12
800027e0:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800027e2:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800027e4:	c1 28       	rjmp	80002808 <gpio_enable_module_pin+0x48>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800027e6:	30 19       	mov	r9,1
800027e8:	f2 0c 09 49 	lsl	r9,r9,r12
800027ec:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800027ee:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800027f0:	c0 c8       	rjmp	80002808 <gpio_enable_module_pin+0x48>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800027f2:	30 19       	mov	r9,1
800027f4:	f2 0c 09 49 	lsl	r9,r9,r12
800027f8:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800027fa:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
800027fc:	c0 68       	rjmp	80002808 <gpio_enable_module_pin+0x48>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800027fe:	30 19       	mov	r9,1
80002800:	f2 0c 09 49 	lsl	r9,r9,r12
80002804:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80002806:	91 99       	st.w	r8[0x24],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80002808:	30 19       	mov	r9,1
8000280a:	f2 0c 09 4c 	lsl	r12,r9,r12
8000280e:	91 2c       	st.w	r8[0x8],r12
80002810:	5e fd       	retal	0
80002812:	d7 03       	nop

80002814 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80002814:	d4 21       	pushm	r4-r7,lr
80002816:	18 97       	mov	r7,r12
80002818:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000281a:	58 0b       	cp.w	r11,0
8000281c:	c0 31       	brne	80002822 <gpio_enable_module+0xe>
8000281e:	30 05       	mov	r5,0
80002820:	c0 d8       	rjmp	8000283a <gpio_enable_module+0x26>
80002822:	30 06       	mov	r6,0
80002824:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80002826:	6e 1b       	ld.w	r11,r7[0x4]
80002828:	6e 0c       	ld.w	r12,r7[0x0]
8000282a:	f0 1f 00 06 	mcall	80002840 <gpio_enable_module+0x2c>
8000282e:	18 45       	or	r5,r12
		gpiomap++;
80002830:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80002832:	2f f6       	sub	r6,-1
80002834:	0c 34       	cp.w	r4,r6
80002836:	fe 9b ff f8 	brhi	80002826 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
8000283a:	0a 9c       	mov	r12,r5
8000283c:	d8 22       	popm	r4-r7,pc
8000283e:	00 00       	add	r0,r0
80002840:	80 00       	ld.sh	r0,r0[0x0]
80002842:	27 c0       	sub	r0,124

80002844 <gpio_set_gpio_pin>:
 *
 * \param pin The pin number.
 */
void gpio_set_gpio_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80002844:	f8 08 16 05 	lsr	r8,r12,0x5
80002848:	a9 68       	lsl	r8,0x8
8000284a:	e0 28 f0 00 	sub	r8,61440
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
8000284e:	30 19       	mov	r9,1
80002850:	f2 0c 09 4c 	lsl	r12,r9,r12
80002854:	f1 4c 00 54 	st.w	r8[84],r12
	/* The GPIO output driver is enabled for that pin. */ 
	gpio_port->oders = 1 << (pin & 0x1F);
80002858:	f1 4c 00 44 	st.w	r8[68],r12
	/* The GPIO module controls that pin. */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000285c:	91 1c       	st.w	r8[0x4],r12
}
8000285e:	5e fc       	retal	r12

80002860 <gpio_enable_pin_glitch_filter>:
 *
 * \param pin The pin number.
 */
void gpio_enable_pin_glitch_filter(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80002860:	f8 08 16 05 	lsr	r8,r12,0x5
80002864:	a9 68       	lsl	r8,0x8
80002866:	e0 28 f0 00 	sub	r8,61440
	
	gpio_port->gfers = 1 << (pin & 0x1F);
8000286a:	30 19       	mov	r9,1
8000286c:	f2 0c 09 4c 	lsl	r12,r9,r12
80002870:	f1 4c 00 c4 	st.w	r8[196],r12
}
80002874:	5e fc       	retal	r12

80002876 <gpio_enable_pin_interrupt>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_pin_interrupt(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80002876:	f8 08 16 05 	lsr	r8,r12,0x5
8000287a:	a9 68       	lsl	r8,0x8
8000287c:	e0 28 f0 00 	sub	r8,61440

	/* Enable the glitch filter. */
	gpio_port->gfers = 1 << (pin & 0x1F);
80002880:	30 19       	mov	r9,1
80002882:	f2 0c 09 4c 	lsl	r12,r9,r12
80002886:	f1 4c 00 c4 	st.w	r8[196],r12
static uint32_t gpio_configure_edge_detector(uint32_t pin, uint32_t mode)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];

	/* Configure the edge detector. */
	switch (mode) {
8000288a:	12 3b       	cp.w	r11,r9
8000288c:	c0 a0       	breq	800028a0 <gpio_enable_pin_interrupt+0x2a>
8000288e:	c0 43       	brcs	80002896 <gpio_enable_pin_interrupt+0x20>
80002890:	58 2b       	cp.w	r11,2
80002892:	c1 11       	brne	800028b4 <gpio_enable_pin_interrupt+0x3e>
80002894:	c0 b8       	rjmp	800028aa <gpio_enable_pin_interrupt+0x34>
	case GPIO_PIN_CHANGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
80002896:	f1 4c 00 a8 	st.w	r8[168],r12
		gpio_port->imr1c = 1 << (pin & 0x1F);
8000289a:	f1 4c 00 b8 	st.w	r8[184],r12
8000289e:	c0 c8       	rjmp	800028b6 <gpio_enable_pin_interrupt+0x40>
		break;

	case GPIO_RISING_EDGE:
		gpio_port->imr0s = 1 << (pin & 0x1F);
800028a0:	f1 4c 00 a4 	st.w	r8[164],r12
		gpio_port->imr1c = 1 << (pin & 0x1F);
800028a4:	f1 4c 00 b8 	st.w	r8[184],r12
800028a8:	c0 78       	rjmp	800028b6 <gpio_enable_pin_interrupt+0x40>
		break;

	case GPIO_FALLING_EDGE:
		gpio_port->imr0c = 1 << (pin & 0x1F);
800028aa:	f1 4c 00 a8 	st.w	r8[168],r12
		gpio_port->imr1s = 1 << (pin & 0x1F);
800028ae:	f1 4c 00 b4 	st.w	r8[180],r12
800028b2:	c0 28       	rjmp	800028b6 <gpio_enable_pin_interrupt+0x40>
800028b4:	5e ff       	retal	1
	if (GPIO_INVALID_ARGUMENT == gpio_configure_edge_detector(pin, mode)) {
		return(GPIO_INVALID_ARGUMENT);
	}

	/* Enable interrupt. */
	gpio_port->iers = 1 << (pin & 0x1F);
800028b6:	f1 4c 00 94 	st.w	r8[148],r12
800028ba:	5e fd       	retal	0

800028bc <gpio_clear_pin_interrupt_flag>:
 *
 * \param pin The pin number.
 */
void gpio_clear_pin_interrupt_flag(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800028bc:	f8 08 16 05 	lsr	r8,r12,0x5
800028c0:	a9 68       	lsl	r8,0x8
800028c2:	e0 28 f0 00 	sub	r8,61440
	gpio_port->ifrc = 1 << (pin & 0x1F);

	/* Restore interrupt enable register. */
	gpio_port->ier = gpio_ier;
#else
	gpio_port->ifrc = 1 << (pin & 0x1F);
800028c6:	30 19       	mov	r9,1
800028c8:	f2 0c 09 4c 	lsl	r12,r9,r12
800028cc:	f1 4c 00 d8 	st.w	r8[216],r12
#endif
}
800028d0:	5e fc       	retal	r12

800028d2 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800028d2:	c0 08       	rjmp	800028d2 <_unhandled_interrupt>

800028d4 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
800028d4:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
800028d8:	49 99       	lddpc	r9,8000293c <INTC_register_interrupt+0x68>
800028da:	f2 08 00 39 	add	r9,r9,r8<<0x3
800028de:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
800028e2:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800028e4:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
800028e8:	58 0a       	cp.w	r10,0
800028ea:	c0 91       	brne	800028fc <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
800028ec:	49 59       	lddpc	r9,80002940 <INTC_register_interrupt+0x6c>
800028ee:	49 6a       	lddpc	r10,80002944 <INTC_register_interrupt+0x70>
800028f0:	12 1a       	sub	r10,r9
800028f2:	fe 79 08 00 	mov	r9,-63488
800028f6:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800028fa:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
800028fc:	58 1a       	cp.w	r10,1
800028fe:	c0 a1       	brne	80002912 <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80002900:	49 09       	lddpc	r9,80002940 <INTC_register_interrupt+0x6c>
80002902:	49 2a       	lddpc	r10,80002948 <INTC_register_interrupt+0x74>
80002904:	12 1a       	sub	r10,r9
80002906:	bf aa       	sbr	r10,0x1e
80002908:	fe 79 08 00 	mov	r9,-63488
8000290c:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80002910:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80002912:	58 2a       	cp.w	r10,2
80002914:	c0 a1       	brne	80002928 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80002916:	48 b9       	lddpc	r9,80002940 <INTC_register_interrupt+0x6c>
80002918:	48 da       	lddpc	r10,8000294c <INTC_register_interrupt+0x78>
8000291a:	12 1a       	sub	r10,r9
8000291c:	bf ba       	sbr	r10,0x1f
8000291e:	fe 79 08 00 	mov	r9,-63488
80002922:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80002926:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80002928:	48 69       	lddpc	r9,80002940 <INTC_register_interrupt+0x6c>
8000292a:	48 aa       	lddpc	r10,80002950 <INTC_register_interrupt+0x7c>
8000292c:	12 1a       	sub	r10,r9
8000292e:	ea 1a c0 00 	orh	r10,0xc000
80002932:	fe 79 08 00 	mov	r9,-63488
80002936:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
8000293a:	5e fc       	retal	r12
8000293c:	80 00       	ld.sh	r0,r0[0x0]
8000293e:	30 34       	mov	r4,3
80002940:	80 00       	ld.sh	r0,r0[0x0]
80002942:	2e 00       	sub	r0,-32
80002944:	80 00       	ld.sh	r0,r0[0x0]
80002946:	2f 04       	sub	r4,-16
80002948:	80 00       	ld.sh	r0,r0[0x0]
8000294a:	2f 12       	sub	r2,-15
8000294c:	80 00       	ld.sh	r0,r0[0x0]
8000294e:	2f 20       	sub	r0,-14
80002950:	80 00       	ld.sh	r0,r0[0x0]
80002952:	2f 2e       	sub	lr,-14

80002954 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80002954:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80002956:	49 18       	lddpc	r8,80002998 <INTC_init_interrupts+0x44>
80002958:	e3 b8 00 01 	mtsr	0x4,r8
8000295c:	49 0e       	lddpc	lr,8000299c <INTC_init_interrupts+0x48>
8000295e:	30 07       	mov	r7,0
80002960:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80002962:	49 0c       	lddpc	r12,800029a0 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80002964:	49 05       	lddpc	r5,800029a4 <INTC_init_interrupts+0x50>
80002966:	10 15       	sub	r5,r8
80002968:	fe 76 08 00 	mov	r6,-63488
8000296c:	c1 08       	rjmp	8000298c <INTC_init_interrupts+0x38>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000296e:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80002970:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80002972:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80002974:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80002978:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000297a:	10 3a       	cp.w	r10,r8
8000297c:	fe 9b ff fc 	brhi	80002974 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80002980:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80002984:	2f f7       	sub	r7,-1
80002986:	2f 8e       	sub	lr,-8
80002988:	59 47       	cp.w	r7,20
8000298a:	c0 50       	breq	80002994 <INTC_init_interrupts+0x40>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000298c:	7c 08       	ld.w	r8,lr[0x0]
8000298e:	58 08       	cp.w	r8,0
80002990:	ce f1       	brne	8000296e <INTC_init_interrupts+0x1a>
80002992:	cf 7b       	rjmp	80002980 <INTC_init_interrupts+0x2c>
80002994:	d8 22       	popm	r4-r7,pc
80002996:	00 00       	add	r0,r0
80002998:	80 00       	ld.sh	r0,r0[0x0]
8000299a:	2e 00       	sub	r0,-32
8000299c:	80 00       	ld.sh	r0,r0[0x0]
8000299e:	30 34       	mov	r4,3
800029a0:	80 00       	ld.sh	r0,r0[0x0]
800029a2:	28 d2       	sub	r2,-115
800029a4:	80 00       	ld.sh	r0,r0[0x0]
800029a6:	2f 04       	sub	r4,-16

800029a8 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
800029a8:	fe 78 08 00 	mov	r8,-63488
800029ac:	e0 69 00 83 	mov	r9,131
800029b0:	f2 0c 01 0c 	sub	r12,r9,r12
800029b4:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
800029b8:	f2 ca ff c0 	sub	r10,r9,-64
800029bc:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800029c0:	58 08       	cp.w	r8,0
800029c2:	c0 21       	brne	800029c6 <_get_interrupt_handler+0x1e>
800029c4:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
800029c6:	f0 08 12 00 	clz	r8,r8
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
800029ca:	48 5a       	lddpc	r10,800029dc <_get_interrupt_handler+0x34>
800029cc:	f4 09 00 39 	add	r9,r10,r9<<0x3
800029d0:	f0 08 11 1f 	rsub	r8,r8,31
800029d4:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
800029d6:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
800029da:	5e fc       	retal	r12
800029dc:	80 00       	ld.sh	r0,r0[0x0]
800029de:	30 34       	mov	r4,3

800029e0 <pm_set_osc0_mode>:
 * \param mode Oscillator 0 mode (i.e. AVR32_PM_OSCCTRL0_MODE_x).
 */
static void pm_set_osc0_mode(volatile avr32_pm_t *pm, unsigned int mode)
{
  // Read
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
800029e0:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.mode = mode;
800029e2:	f1 db d0 03 	bfins	r8,r11,0x0,0x3
  // Write
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
800029e6:	99 a8       	st.w	r12[0x28],r8
}
800029e8:	5e fc       	retal	r12
800029ea:	d7 03       	nop

800029ec <pm_enable_osc0_crystal>:
  pm_set_osc0_mode(pm, AVR32_PM_OSCCTRL0_MODE_EXT_CLOCK);
}


void pm_enable_osc0_crystal(volatile avr32_pm_t *pm, unsigned int fosc0)
{
800029ec:	d4 01       	pushm	lr
  pm_set_osc0_mode(pm, (fosc0 <  900000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G0 :
800029ee:	ec 5b bb 9f 	cp.w	r11,899999
800029f2:	e0 8b 00 04 	brhi	800029fa <pm_enable_osc0_crystal+0xe>
800029f6:	30 4b       	mov	r11,4
800029f8:	c1 38       	rjmp	80002a1e <pm_enable_osc0_crystal+0x32>
800029fa:	e0 68 c6 bf 	mov	r8,50879
800029fe:	ea 18 00 2d 	orh	r8,0x2d
80002a02:	10 3b       	cp.w	r11,r8
80002a04:	e0 8b 00 04 	brhi	80002a0c <pm_enable_osc0_crystal+0x20>
80002a08:	30 5b       	mov	r11,5
80002a0a:	c0 a8       	rjmp	80002a1e <pm_enable_osc0_crystal+0x32>
80002a0c:	e0 68 12 00 	mov	r8,4608
80002a10:	ea 18 00 7a 	orh	r8,0x7a
80002a14:	10 3b       	cp.w	r11,r8
80002a16:	f9 bb 03 06 	movlo	r11,6
80002a1a:	f9 bb 02 07 	movhs	r11,7
80002a1e:	f0 1f 00 02 	mcall	80002a24 <pm_enable_osc0_crystal+0x38>
                       (fosc0 < 3000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G1 :
                       (fosc0 < 8000000) ? AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G2 :
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}
80002a22:	d8 02       	popm	pc
80002a24:	80 00       	ld.sh	r0,r0[0x0]
80002a26:	29 e0       	sub	r0,-98

80002a28 <pm_enable_clk0_no_wait>:


void pm_enable_clk0_no_wait(volatile avr32_pm_t *pm, unsigned int startup)
{
  // Read register
  u_avr32_pm_oscctrl0_t u_avr32_pm_oscctrl0 = {pm->oscctrl0};
80002a28:	78 a8       	ld.w	r8,r12[0x28]
  // Modify
  u_avr32_pm_oscctrl0.OSCCTRL0.startup = startup;
80002a2a:	f1 db d1 03 	bfins	r8,r11,0x8,0x3
  // Write back
  pm->oscctrl0 = u_avr32_pm_oscctrl0.oscctrl0;
80002a2e:	99 a8       	st.w	r12[0x28],r8

  pm->mcctrl |= AVR32_PM_MCCTRL_OSC0EN_MASK;
80002a30:	78 08       	ld.w	r8,r12[0x0]
80002a32:	a3 a8       	sbr	r8,0x2
80002a34:	99 08       	st.w	r12[0x0],r8
}
80002a36:	5e fc       	retal	r12

80002a38 <pm_wait_for_clk0_ready>:


void pm_wait_for_clk0_ready(volatile avr32_pm_t *pm)
{
  while (!(pm->poscsr & AVR32_PM_POSCSR_OSC0RDY_MASK));
80002a38:	79 58       	ld.w	r8,r12[0x54]
80002a3a:	e2 18 00 80 	andl	r8,0x80,COH
80002a3e:	cf d0       	breq	80002a38 <pm_wait_for_clk0_ready>
}
80002a40:	5e fc       	retal	r12
80002a42:	d7 03       	nop

80002a44 <pm_enable_clk0>:
                                           AVR32_PM_OSCCTRL0_MODE_CRYSTAL_G3);
}


void pm_enable_clk0(volatile avr32_pm_t *pm, unsigned int startup)
{
80002a44:	eb cd 40 80 	pushm	r7,lr
80002a48:	18 97       	mov	r7,r12
  pm_enable_clk0_no_wait(pm, startup);
80002a4a:	f0 1f 00 04 	mcall	80002a58 <pm_enable_clk0+0x14>
  pm_wait_for_clk0_ready(pm);
80002a4e:	0e 9c       	mov	r12,r7
80002a50:	f0 1f 00 03 	mcall	80002a5c <pm_enable_clk0+0x18>
}
80002a54:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a58:	80 00       	ld.sh	r0,r0[0x0]
80002a5a:	2a 28       	sub	r8,-94
80002a5c:	80 00       	ld.sh	r0,r0[0x0]
80002a5e:	2a 38       	sub	r8,-93

80002a60 <pm_switch_to_clock>:


void pm_switch_to_clock(volatile avr32_pm_t *pm, unsigned long clock)
{
  // Read
  u_avr32_pm_mcctrl_t u_avr32_pm_mcctrl = {pm->mcctrl};
80002a60:	78 08       	ld.w	r8,r12[0x0]
  // Modify
  u_avr32_pm_mcctrl.MCCTRL.mcsel = clock;
80002a62:	f1 db d0 02 	bfins	r8,r11,0x0,0x2
  // Write back
  pm->mcctrl = u_avr32_pm_mcctrl.mcctrl;
80002a66:	99 08       	st.w	r12[0x0],r8
}
80002a68:	5e fc       	retal	r12
80002a6a:	d7 03       	nop

80002a6c <pm_switch_to_osc0>:


void pm_switch_to_osc0(volatile avr32_pm_t *pm, unsigned int fosc0, unsigned int startup)
{
80002a6c:	eb cd 40 c0 	pushm	r6-r7,lr
80002a70:	18 97       	mov	r7,r12
80002a72:	14 96       	mov	r6,r10
  pm_enable_osc0_crystal(pm, fosc0);            // Enable the Osc0 in crystal mode
80002a74:	f0 1f 00 06 	mcall	80002a8c <pm_switch_to_osc0+0x20>
  pm_enable_clk0(pm, startup);                  // Crystal startup time - This parameter is critical and depends on the characteristics of the crystal
80002a78:	0c 9b       	mov	r11,r6
80002a7a:	0e 9c       	mov	r12,r7
80002a7c:	f0 1f 00 05 	mcall	80002a90 <pm_switch_to_osc0+0x24>
  pm_switch_to_clock(pm, AVR32_PM_MCSEL_OSC0);  // Then switch main clock to Osc0
80002a80:	30 1b       	mov	r11,1
80002a82:	0e 9c       	mov	r12,r7
80002a84:	f0 1f 00 04 	mcall	80002a94 <pm_switch_to_osc0+0x28>
}
80002a88:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002a8c:	80 00       	ld.sh	r0,r0[0x0]
80002a8e:	29 ec       	sub	r12,-98
80002a90:	80 00       	ld.sh	r0,r0[0x0]
80002a92:	2a 44       	sub	r4,-92
80002a94:	80 00       	ld.sh	r0,r0[0x0]
80002a96:	2a 60       	sub	r0,-90

80002a98 <usart_set_async_baudrate>:
 *
 * \retval USART_SUCCESS        Baud rate successfully initialized.
 * \retval USART_INVALID_INPUT  Baud rate set point is out of range for the given input clock frequency.
 */
static int usart_set_async_baudrate(volatile avr32_usart_t *usart, unsigned int baudrate, unsigned long pba_hz)
{
80002a98:	d4 01       	pushm	lr
  unsigned int over = (pba_hz >= 16 * baudrate) ? 16 : 8;
80002a9a:	f6 08 15 04 	lsl	r8,r11,0x4
80002a9e:	14 38       	cp.w	r8,r10
80002aa0:	f9 b8 08 10 	movls	r8,16
80002aa4:	f9 b8 0b 08 	movhi	r8,8
  unsigned int cd_fp = ((1 << AVR32_USART_BRGR_FP_SIZE) * pba_hz + (over * baudrate) / 2) / (over * baudrate);
80002aa8:	f0 0b 02 4b 	mul	r11,r8,r11
80002aac:	f6 09 16 01 	lsr	r9,r11,0x1
80002ab0:	f2 0a 00 3a 	add	r10,r9,r10<<0x3
80002ab4:	f4 0b 0d 0a 	divu	r10,r10,r11
  unsigned int cd = cd_fp >> AVR32_USART_BRGR_FP_SIZE;
80002ab8:	f4 09 16 03 	lsr	r9,r10,0x3
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
80002abc:	f2 cb 00 01 	sub	r11,r9,1
80002ac0:	e0 4b ff fe 	cp.w	r11,65534
80002ac4:	e0 88 00 03 	brls	80002aca <usart_set_async_baudrate+0x32>
80002ac8:	da 0a       	popm	pc,r12=1
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
80002aca:	78 1b       	ld.w	r11,r12[0x4]
  unsigned int fp = cd_fp & ((1 << AVR32_USART_BRGR_FP_SIZE) - 1);

  if (cd < 1 || cd > (1 << AVR32_USART_BRGR_CD_SIZE) - 1)
    return USART_INVALID_INPUT;

  usart->mr = (usart->mr & ~(AVR32_USART_MR_USCLKS_MASK |
80002acc:	e8 6e 00 00 	mov	lr,524288
80002ad0:	59 08       	cp.w	r8,16
80002ad2:	fc 08 17 10 	movne	r8,lr
80002ad6:	f9 b8 00 00 	moveq	r8,0
80002ada:	e4 1b ff f7 	andh	r11,0xfff7
80002ade:	e0 1b fe cf 	andl	r11,0xfecf
80002ae2:	16 48       	or	r8,r11
80002ae4:	99 18       	st.w	r12[0x4],r8
                             AVR32_USART_MR_SYNC_MASK |
                             AVR32_USART_MR_OVER_MASK)) |
              AVR32_USART_MR_USCLKS_MCK << AVR32_USART_MR_USCLKS_OFFSET |
              ((over == 16) ? AVR32_USART_MR_OVER_X16 : AVR32_USART_MR_OVER_X8) << AVR32_USART_MR_OVER_OFFSET;

  usart->brgr = cd << AVR32_USART_BRGR_CD_OFFSET |
80002ae6:	f5 da c0 03 	bfextu	r10,r10,0x0,0x3
80002aea:	f3 ea 11 09 	or	r9,r9,r10<<0x10
80002aee:	99 89       	st.w	r12[0x20],r9
80002af0:	d8 0a       	popm	pc,r12=0

80002af2 <usart_reset>:
//! @{


void usart_reset(volatile avr32_usart_t *usart)
{
  bool global_interrupt_enabled = cpu_irq_is_enabled();
80002af2:	e1 b8 00 00 	mfsr	r8,0x0

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
80002af6:	e6 18 00 01 	andh	r8,0x1,COH
80002afa:	c0 71       	brne	80002b08 <usart_reset+0x16>
80002afc:	d3 03       	ssrf	0x10
  usart->idr = 0xFFFFFFFF;
80002afe:	3f f8       	mov	r8,-1
80002b00:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80002b02:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();
80002b04:	d5 03       	csrf	0x10
80002b06:	c0 48       	rjmp	80002b0e <usart_reset+0x1c>
  bool global_interrupt_enabled = cpu_irq_is_enabled();

  // Disable all USART interrupts.
  // Interrupts needed should be set explicitly on every reset.
  if (global_interrupt_enabled) cpu_irq_disable();
  usart->idr = 0xFFFFFFFF;
80002b08:	3f f8       	mov	r8,-1
80002b0a:	99 38       	st.w	r12[0xc],r8
  usart->csr;
80002b0c:	78 58       	ld.w	r8,r12[0x14]
  if (global_interrupt_enabled) cpu_irq_enable();

  // Reset mode and other registers that could cause unpredictable behavior after reset.
  usart->mr = 0;
80002b0e:	30 08       	mov	r8,0
80002b10:	99 18       	st.w	r12[0x4],r8
  usart->rtor = 0;
80002b12:	99 98       	st.w	r12[0x24],r8
  usart->ttgr = 0;
80002b14:	99 a8       	st.w	r12[0x28],r8

  // Shutdown TX and RX (will be re-enabled when setup has successfully completed),
  // reset status bits and turn off DTR and RTS.
  usart->cr = AVR32_USART_CR_RSTRX_MASK   |
80002b16:	ea 68 61 0c 	mov	r8,680204
80002b1a:	99 08       	st.w	r12[0x0],r8
#ifndef AVR32_USART_440_H_INCLUDED
// Note: Modem Signal Management DTR-DSR-DCD-RI are not included in USART rev.440.
              AVR32_USART_CR_DTRDIS_MASK  |
#endif
              AVR32_USART_CR_RTSDIS_MASK;
}
80002b1c:	5e fc       	retal	r12
80002b1e:	d7 03       	nop

80002b20 <usart_init_rs232>:


int usart_init_rs232(volatile avr32_usart_t *usart, const usart_options_t *opt, long pba_hz)
{
80002b20:	eb cd 40 e0 	pushm	r5-r7,lr
80002b24:	18 96       	mov	r6,r12
80002b26:	16 97       	mov	r7,r11
80002b28:	14 95       	mov	r5,r10
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);
80002b2a:	f0 1f 00 2f 	mcall	80002be4 <usart_init_rs232+0xc4>

  // Check input values.
  if (!opt || // Null pointer.
80002b2e:	58 07       	cp.w	r7,0
80002b30:	c5 80       	breq	80002be0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
80002b32:	0f c8       	ld.ub	r8,r7[0x4]
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80002b34:	30 49       	mov	r9,4
80002b36:	f2 08 18 00 	cp.b	r8,r9
80002b3a:	e0 88 00 53 	brls	80002be0 <usart_init_rs232+0xc0>
80002b3e:	30 99       	mov	r9,9
80002b40:	f2 08 18 00 	cp.b	r8,r9
80002b44:	e0 8b 00 4e 	brhi	80002be0 <usart_init_rs232+0xc0>
      opt->charlength < 5 || opt->charlength > 9 ||
      opt->paritytype > 7 ||
80002b48:	0f d9       	ld.ub	r9,r7[0x5]
80002b4a:	30 78       	mov	r8,7
80002b4c:	f0 09 18 00 	cp.b	r9,r8
80002b50:	e0 8b 00 48 	brhi	80002be0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
80002b54:	8e 39       	ld.sh	r9,r7[0x6]
80002b56:	e0 68 01 01 	mov	r8,257
80002b5a:	f0 09 19 00 	cp.h	r9,r8
80002b5e:	e0 8b 00 41 	brhi	80002be0 <usart_init_rs232+0xc0>
      opt->channelmode > 3 ||
80002b62:	ef 39 00 08 	ld.ub	r9,r7[8]
80002b66:	30 38       	mov	r8,3
80002b68:	f0 09 18 00 	cp.b	r9,r8
80002b6c:	e0 8b 00 3a 	brhi	80002be0 <usart_init_rs232+0xc0>
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
80002b70:	0a 9a       	mov	r10,r5
80002b72:	6e 0b       	ld.w	r11,r7[0x0]
80002b74:	0c 9c       	mov	r12,r6
80002b76:	f0 1f 00 1d 	mcall	80002be8 <usart_init_rs232+0xc8>
{
  // Reset the USART and shutdown TX and RX.
  usart_reset(usart);

  // Check input values.
  if (!opt || // Null pointer.
80002b7a:	58 1c       	cp.w	r12,1
80002b7c:	c3 20       	breq	80002be0 <usart_init_rs232+0xc0>
      opt->stopbits > 2 + 255 ||
      opt->channelmode > 3 ||
      usart_set_async_baudrate(usart, opt->baudrate, pba_hz) == USART_INVALID_INPUT)
    return USART_INVALID_INPUT;

  if (opt->charlength == 9)
80002b7e:	0f c8       	ld.ub	r8,r7[0x4]
80002b80:	30 99       	mov	r9,9
80002b82:	f2 08 18 00 	cp.b	r8,r9
80002b86:	c0 51       	brne	80002b90 <usart_init_rs232+0x70>
  {
    // Character length set to 9 bits. MODE9 dominates CHRL.
    usart->mr |= AVR32_USART_MR_MODE9_MASK;
80002b88:	6c 18       	ld.w	r8,r6[0x4]
80002b8a:	b1 b8       	sbr	r8,0x11
80002b8c:	8d 18       	st.w	r6[0x4],r8
80002b8e:	c0 68       	rjmp	80002b9a <usart_init_rs232+0x7a>
  }
  else
  {
    // CHRL gives the character length (- 5) when MODE9 = 0.
    usart->mr |= (opt->charlength - 5) << AVR32_USART_MR_CHRL_OFFSET;
80002b90:	6c 19       	ld.w	r9,r6[0x4]
80002b92:	20 58       	sub	r8,5
80002b94:	f3 e8 10 68 	or	r8,r9,r8<<0x6
80002b98:	8d 18       	st.w	r6[0x4],r8
  }

  usart->mr |= opt->paritytype << AVR32_USART_MR_PAR_OFFSET |
80002b9a:	6c 19       	ld.w	r9,r6[0x4]
80002b9c:	ef 3a 00 08 	ld.ub	r10,r7[8]
80002ba0:	0f d8       	ld.ub	r8,r7[0x5]
80002ba2:	a9 78       	lsl	r8,0x9
80002ba4:	f1 ea 10 e8 	or	r8,r8,r10<<0xe
80002ba8:	12 48       	or	r8,r9
80002baa:	8d 18       	st.w	r6[0x4],r8
               opt->channelmode << AVR32_USART_MR_CHMODE_OFFSET;

  if (opt->stopbits > USART_2_STOPBITS)
80002bac:	8e 38       	ld.sh	r8,r7[0x6]
80002bae:	30 29       	mov	r9,2
80002bb0:	f2 08 19 00 	cp.h	r8,r9
80002bb4:	e0 88 00 09 	brls	80002bc6 <usart_init_rs232+0xa6>
  {
    // Set two stop bits
    usart->mr |= AVR32_USART_MR_NBSTOP_2 << AVR32_USART_MR_NBSTOP_OFFSET;
80002bb8:	6c 18       	ld.w	r8,r6[0x4]
80002bba:	ad b8       	sbr	r8,0xd
80002bbc:	8d 18       	st.w	r6[0x4],r8
    // and a timeguard period gives the rest.
    usart->ttgr = opt->stopbits - USART_2_STOPBITS;
80002bbe:	8e b8       	ld.uh	r8,r7[0x6]
80002bc0:	20 28       	sub	r8,2
80002bc2:	8d a8       	st.w	r6[0x28],r8
80002bc4:	c0 68       	rjmp	80002bd0 <usart_init_rs232+0xb0>
  }
  else
    // Insert 1, 1.5 or 2 stop bits.
    usart->mr |= opt->stopbits << AVR32_USART_MR_NBSTOP_OFFSET;
80002bc6:	6c 19       	ld.w	r9,r6[0x4]
80002bc8:	5c 78       	castu.h	r8
80002bca:	f3 e8 10 c8 	or	r8,r9,r8<<0xc
80002bce:	8d 18       	st.w	r6[0x4],r8

  // Set normal mode.
  usart->mr = (usart->mr & ~AVR32_USART_MR_MODE_MASK) |
80002bd0:	6c 18       	ld.w	r8,r6[0x4]
80002bd2:	e0 18 ff f0 	andl	r8,0xfff0
80002bd6:	8d 18       	st.w	r6[0x4],r8
              AVR32_USART_MR_MODE_NORMAL << AVR32_USART_MR_MODE_OFFSET;

  // Setup complete; enable communication.
  // Enable input and output.
  usart->cr = AVR32_USART_CR_RXEN_MASK |
80002bd8:	35 08       	mov	r8,80
80002bda:	8d 08       	st.w	r6[0x0],r8
80002bdc:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
              AVR32_USART_CR_TXEN_MASK;

  return USART_SUCCESS;
80002be0:	e3 cf 90 e0 	ldm	sp++,r5-r7,pc,r12=1
80002be4:	80 00       	ld.sh	r0,r0[0x0]
80002be6:	2a f2       	sub	r2,-81
80002be8:	80 00       	ld.sh	r0,r0[0x0]
80002bea:	2a 98       	sub	r8,-87

80002bec <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80002bec:	e0 7d 00 00 	mov	sp,65536

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80002bf0:	fe c0 fd f0 	sub	r0,pc,-528

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80002bf4:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80002bf8:	d5 53       	csrf	0x15
  cp      r0, r1
80002bfa:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
80002bfc:	31 81       	mov	r1,24
  lda.w   r2, _data_lma
80002bfe:	02 30       	cp.w	r0,r1
idata_load_loop:
  ld.d    r4, r2++
80002c00:	c0 72       	brcc	80002c0e <idata_load_loop_end>
  st.d    r0++, r4
80002c02:	fe c2 fb 2a 	sub	r2,pc,-1238

80002c06 <idata_load_loop>:
  cp      r0, r1
  brlo    idata_load_loop
80002c06:	a5 05       	ld.d	r4,r2++
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80002c08:	a1 24       	st.d	r0++,r4
  lda.w   r1, _end
80002c0a:	02 30       	cp.w	r0,r1
  cp      r0, r1
80002c0c:	cf d3       	brcs	80002c06 <idata_load_loop>

80002c0e <idata_load_loop_end>:
  brhs    udata_clear_loop_end
80002c0e:	31 80       	mov	r0,24
  mov     r2, 0
80002c10:	e0 61 01 28 	mov	r1,296
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
80002c14:	02 30       	cp.w	r0,r1
  cp      r0, r1
80002c16:	c0 62       	brcc	80002c22 <udata_clear_loop_end>
  brlo    udata_clear_loop
80002c18:	30 02       	mov	r2,0
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80002c1a:	30 03       	mov	r3,0

80002c1c <udata_clear_loop>:
80002c1c:	a1 22       	st.d	r0++,r2
80002c1e:	02 30       	cp.w	r0,r1
80002c20:	cf e3       	brcs	80002c1c <udata_clear_loop>

80002c22 <udata_clear_loop_end>:
80002c22:	fe cf 05 fe 	sub	pc,pc,1534
80002c26:	d7 03       	nop

Disassembly of section .exception:

80002e00 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
80002e00:	c0 08       	rjmp	80002e00 <_evba>
	...

80002e04 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
80002e04:	c0 08       	rjmp	80002e04 <_handle_TLB_Multiple_Hit>
	...

80002e08 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
80002e08:	c0 08       	rjmp	80002e08 <_handle_Bus_Error_Data_Fetch>
	...

80002e0c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
80002e0c:	c0 08       	rjmp	80002e0c <_handle_Bus_Error_Instruction_Fetch>
	...

80002e10 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
80002e10:	c0 08       	rjmp	80002e10 <_handle_NMI>
	...

80002e14 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
80002e14:	c0 08       	rjmp	80002e14 <_handle_Instruction_Address>
	...

80002e18 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
80002e18:	c0 08       	rjmp	80002e18 <_handle_ITLB_Protection>
	...

80002e1c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
80002e1c:	c0 08       	rjmp	80002e1c <_handle_Breakpoint>
	...

80002e20 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
80002e20:	c0 08       	rjmp	80002e20 <_handle_Illegal_Opcode>
	...

80002e24 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
80002e24:	c0 08       	rjmp	80002e24 <_handle_Unimplemented_Instruction>
	...

80002e28 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
80002e28:	c0 08       	rjmp	80002e28 <_handle_Privilege_Violation>
	...

80002e2c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR32UC and AVR32AP.
_handle_Floating_Point:
	rjmp $
80002e2c:	c0 08       	rjmp	80002e2c <_handle_Floating_Point>
	...

80002e30 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
	rjmp $
80002e30:	c0 08       	rjmp	80002e30 <_handle_Coprocessor_Absent>
	...

80002e34 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
80002e34:	c0 08       	rjmp	80002e34 <_handle_Data_Address_Read>
	...

80002e38 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
80002e38:	c0 08       	rjmp	80002e38 <_handle_Data_Address_Write>
	...

80002e3c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
80002e3c:	c0 08       	rjmp	80002e3c <_handle_DTLB_Protection_Read>
	...

80002e40 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
80002e40:	c0 08       	rjmp	80002e40 <_handle_DTLB_Protection_Write>
	...

80002e44 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
80002e44:	c0 08       	rjmp	80002e44 <_handle_DTLB_Modified>
	...

80002e50 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
80002e50:	c0 08       	rjmp	80002e50 <_handle_ITLB_Miss>
	...

80002e60 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
80002e60:	c0 08       	rjmp	80002e60 <_handle_DTLB_Miss_Read>
	...

80002e70 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
80002e70:	c0 08       	rjmp	80002e70 <_handle_DTLB_Miss_Write>
	...

80002f00 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	rjmp $
80002f00:	c0 08       	rjmp	80002f00 <_handle_Supervisor_Call>
80002f02:	d7 03       	nop

80002f04 <_int0>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80002f04:	30 0c       	mov	r12,0
80002f06:	fe b0 fd 51 	rcall	800029a8 <_get_interrupt_handler>
80002f0a:	58 0c       	cp.w	r12,0
80002f0c:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80002f10:	d6 03       	rete

80002f12 <_int1>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80002f12:	30 1c       	mov	r12,1
80002f14:	fe b0 fd 4a 	rcall	800029a8 <_get_interrupt_handler>
80002f18:	58 0c       	cp.w	r12,0
80002f1a:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80002f1e:	d6 03       	rete

80002f20 <_int2>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80002f20:	30 2c       	mov	r12,2
80002f22:	fe b0 fd 43 	rcall	800029a8 <_get_interrupt_handler>
80002f26:	58 0c       	cp.w	r12,0
80002f28:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80002f2c:	d6 03       	rete

80002f2e <_int3>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80002f2e:	30 3c       	mov	r12,3
80002f30:	fe b0 fd 3c 	rcall	800029a8 <_get_interrupt_handler>
80002f34:	58 0c       	cp.w	r12,0
80002f36:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80002f3a:	d6 03       	rete
80002f3c:	d7 03       	nop
80002f3e:	d7 03       	nop
80002f40:	d7 03       	nop
80002f42:	d7 03       	nop
80002f44:	d7 03       	nop
80002f46:	d7 03       	nop
80002f48:	d7 03       	nop
80002f4a:	d7 03       	nop
80002f4c:	d7 03       	nop
80002f4e:	d7 03       	nop
80002f50:	d7 03       	nop
80002f52:	d7 03       	nop
80002f54:	d7 03       	nop
80002f56:	d7 03       	nop
80002f58:	d7 03       	nop
80002f5a:	d7 03       	nop
80002f5c:	d7 03       	nop
80002f5e:	d7 03       	nop
80002f60:	d7 03       	nop
80002f62:	d7 03       	nop
80002f64:	d7 03       	nop
80002f66:	d7 03       	nop
80002f68:	d7 03       	nop
80002f6a:	d7 03       	nop
80002f6c:	d7 03       	nop
80002f6e:	d7 03       	nop
80002f70:	d7 03       	nop
80002f72:	d7 03       	nop
80002f74:	d7 03       	nop
80002f76:	d7 03       	nop
80002f78:	d7 03       	nop
80002f7a:	d7 03       	nop
80002f7c:	d7 03       	nop
80002f7e:	d7 03       	nop
80002f80:	d7 03       	nop
80002f82:	d7 03       	nop
80002f84:	d7 03       	nop
80002f86:	d7 03       	nop
80002f88:	d7 03       	nop
80002f8a:	d7 03       	nop
80002f8c:	d7 03       	nop
80002f8e:	d7 03       	nop
80002f90:	d7 03       	nop
80002f92:	d7 03       	nop
80002f94:	d7 03       	nop
80002f96:	d7 03       	nop
80002f98:	d7 03       	nop
80002f9a:	d7 03       	nop
80002f9c:	d7 03       	nop
80002f9e:	d7 03       	nop
80002fa0:	d7 03       	nop
80002fa2:	d7 03       	nop
80002fa4:	d7 03       	nop
80002fa6:	d7 03       	nop
80002fa8:	d7 03       	nop
80002faa:	d7 03       	nop
80002fac:	d7 03       	nop
80002fae:	d7 03       	nop
80002fb0:	d7 03       	nop
80002fb2:	d7 03       	nop
80002fb4:	d7 03       	nop
80002fb6:	d7 03       	nop
80002fb8:	d7 03       	nop
80002fba:	d7 03       	nop
80002fbc:	d7 03       	nop
80002fbe:	d7 03       	nop
80002fc0:	d7 03       	nop
80002fc2:	d7 03       	nop
80002fc4:	d7 03       	nop
80002fc6:	d7 03       	nop
80002fc8:	d7 03       	nop
80002fca:	d7 03       	nop
80002fcc:	d7 03       	nop
80002fce:	d7 03       	nop
80002fd0:	d7 03       	nop
80002fd2:	d7 03       	nop
80002fd4:	d7 03       	nop
80002fd6:	d7 03       	nop
80002fd8:	d7 03       	nop
80002fda:	d7 03       	nop
80002fdc:	d7 03       	nop
80002fde:	d7 03       	nop
80002fe0:	d7 03       	nop
80002fe2:	d7 03       	nop
80002fe4:	d7 03       	nop
80002fe6:	d7 03       	nop
80002fe8:	d7 03       	nop
80002fea:	d7 03       	nop
80002fec:	d7 03       	nop
80002fee:	d7 03       	nop
80002ff0:	d7 03       	nop
80002ff2:	d7 03       	nop
80002ff4:	d7 03       	nop
80002ff6:	d7 03       	nop
80002ff8:	d7 03       	nop
80002ffa:	d7 03       	nop
80002ffc:	d7 03       	nop
80002ffe:	d7 03       	nop
